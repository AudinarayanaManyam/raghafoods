{"version":3,"sources":["turbopack:///[project]/node_modules/next/dist/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/node_modules/next/dist/esm/client/components/is-next-router-error.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-error.js","turbopack:///[project]/node_modules/next/dist/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","turbopack:///[project]/node_modules/next/dist/src/lib/framework/boundary-constants.tsx","turbopack:///[project]/node_modules/next/dist/src/shared/lib/invariant-error.ts","turbopack:///[project]/node_modules/next/dist/esm/server/app-render/dynamic-rendering.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/hooks-server-context.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/static-generation-bailout.js","turbopack:///[project]/node_modules/next/dist/esm/server/dynamic-rendering-utils.js","turbopack:///[project]/node_modules/next/dist/esm/lib/scheduler.js","turbopack:///[project]/node_modules/next/dist/esm/server/lib/router-utils/is-postpone.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unstable-rethrow.server.js","turbopack:///[project]/node_modules/next/dist/src/client/components/bailout-to-client-rendering.ts","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/utils/warn-once.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/http-access-fallback/error-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation-untracked.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/layout-router.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-find-source-map-url.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-build-id.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/set-cache-busting-search-param.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/handle-isr-error.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/error-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/disable-smooth-scroll.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/not-found.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation.react-server.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/redirect-boundary.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/app-router-headers.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/segment.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/match-segments.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/get-segment-value.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unrecognized-action-error.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/forbidden.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unauthorized.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/bfcache.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/cache-busting-search-param.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/segment-cache/segment-value-encoding.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/use-action-queue.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/navigation.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/nav-failure-handler.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unresolved-thenable.js","turbopack:///[project]/node_modules/next/dist/esm/client/route-params.js","turbopack:///[project]/node_modules/next/dist/esm/client/app-call-server.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js","turbopack:///[project]/node_modules/next/dist/esm/client/flight-data-helpers.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/is-thenable.js","turbopack:///[project]/node_modules/next/dist/esm/client/components/unstable-rethrow.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/hash.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js","turbopack:///[project]/node_modules/next/dist/src/client/components/render-from-template-context.tsx","turbopack:///[project]/node_modules/next/dist/esm/server/create-deduped-by-callsite-server-error-logger.js","turbopack:///[project]/node_modules/next/dist/esm/shared/lib/utils/reflect-utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/utils.js","turbopack:///[project]/node_modules/next/dist/esm/server/request/search-params.js","turbopack:///[project]/node_modules/next/dist/src/server/request/params.ts","turbopack:///[project]/node_modules/next/dist/src/client/components/client-page.tsx","turbopack:///[project]/node_modules/next/dist/src/client/components/client-segment.tsx","turbopack:///[project]/node_modules/next/dist/src/lib/metadata/generate/icon-mark.tsx","turbopack:///[project]/node_modules/next/dist/src/client/components/metadata/async-metadata.tsx","turbopack:///[project]/node_modules/next/dist/src/lib/framework/boundary-components.tsx"],"sourcesContent":["export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import { isHTTPAccessFallbackError } from './http-access-fallback/http-access-fallback';\r\nimport { isRedirectError } from './redirect-error';\r\n/**\r\n * Returns true if the error is a navigation signal error. These errors are\r\n * thrown by user code to perform navigation operations and interrupt the React\r\n * render.\r\n */ export function isNextRouterError(error) {\r\n    return isRedirectError(error) || isHTTPAccessFallbackError(error);\r\n}\r\n\r\n//# sourceMappingURL=is-next-router-error.js.map","export var RedirectStatusCode = /*#__PURE__*/ function(RedirectStatusCode) {\r\n    RedirectStatusCode[RedirectStatusCode[\"SeeOther\"] = 303] = \"SeeOther\";\r\n    RedirectStatusCode[RedirectStatusCode[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\r\n    RedirectStatusCode[RedirectStatusCode[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\r\n    return RedirectStatusCode;\r\n}({});\r\n\r\n//# sourceMappingURL=redirect-status-code.js.map","import { RedirectStatusCode } from './redirect-status-code';\r\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT';\r\nexport var RedirectType = /*#__PURE__*/ function(RedirectType) {\r\n    RedirectType[\"push\"] = \"push\";\r\n    RedirectType[\"replace\"] = \"replace\";\r\n    return RedirectType;\r\n}({});\r\n/**\r\n * Checks an error to determine if it's an error generated by the\r\n * `redirect(url)` helper.\r\n *\r\n * @param error the error that may reference a redirect error\r\n * @returns true if the error is a redirect error\r\n */ export function isRedirectError(error) {\r\n    if (typeof error !== 'object' || error === null || !('digest' in error) || typeof error.digest !== 'string') {\r\n        return false;\r\n    }\r\n    const digest = error.digest.split(';');\r\n    const [errorCode, type] = digest;\r\n    const destination = digest.slice(2, -2).join(';');\r\n    const status = digest.at(-2);\r\n    const statusCode = Number(status);\r\n    return errorCode === REDIRECT_ERROR_CODE && (type === 'replace' || type === 'push') && typeof destination === 'string' && !isNaN(statusCode) && statusCode in RedirectStatusCode;\r\n}\r\n\r\n//# sourceMappingURL=redirect-error.js.map","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","/**\r\n * The functions provided by this module are used to communicate certain properties\r\n * about the currently running code so that Next.js can make decisions on how to handle\r\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\r\n *\r\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\r\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\r\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\r\n * Dynamic indications.\r\n *\r\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\r\n * the currently executing code simply declares that the current scope is dynamic but if you use it\r\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\r\n * make the default dynamic to begin with because the only way you would ever be static is inside\r\n * a cache scope which this indication does not affect.\r\n *\r\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\r\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\r\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\r\n * read that data outside the cache and pass it in as an argument to the cached function.\r\n */ // Once postpone is in stable we should switch to importing the postpone export directly\r\nimport React from 'react';\r\nimport { DynamicServerError } from '../../client/components/hooks-server-context';\r\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\r\nimport { getRuntimeStagePromise, workUnitAsyncStorage } from './work-unit-async-storage.external';\r\nimport { workAsyncStorage } from '../app-render/work-async-storage.external';\r\nimport { makeHangingPromise } from '../dynamic-rendering-utils';\r\nimport { METADATA_BOUNDARY_NAME, VIEWPORT_BOUNDARY_NAME, OUTLET_BOUNDARY_NAME, ROOT_LAYOUT_BOUNDARY_NAME } from '../../lib/framework/boundary-constants';\r\nimport { scheduleOnNextTick } from '../../lib/scheduler';\r\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\r\nimport { InvariantError } from '../../shared/lib/invariant-error';\r\nconst hasPostpone = typeof React.unstable_postpone === 'function';\r\nexport function createDynamicTrackingState(isDebugDynamicAccesses) {\r\n    return {\r\n        isDebugDynamicAccesses,\r\n        dynamicAccesses: [],\r\n        syncDynamicErrorWithStack: null\r\n    };\r\n}\r\nexport function createDynamicValidationState() {\r\n    return {\r\n        hasSuspenseAboveBody: false,\r\n        hasDynamicMetadata: false,\r\n        hasDynamicViewport: false,\r\n        hasAllowedDynamic: false,\r\n        dynamicErrors: []\r\n    };\r\n}\r\nexport function getFirstDynamicReason(trackingState) {\r\n    var _trackingState_dynamicAccesses_;\r\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\r\n}\r\n/**\r\n * This function communicates that the current scope should be treated as dynamic.\r\n *\r\n * In most cases this function is a no-op but if called during\r\n * a PPR prerender it will postpone the current sub-tree and calling\r\n * it during a normal prerender will cause the entire prerender to abort\r\n */ export function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'cache':\r\n            case 'unstable-cache':\r\n                // Inside cache scopes, marking a scope as dynamic has no effect,\r\n                // because the outer cache scope creates a cache boundary. This is\r\n                // subtly different from reading a dynamic data source, which is\r\n                // forbidden inside a cache scope.\r\n                return;\r\n            case 'private-cache':\r\n                // A private cache scope is already dynamic by definition.\r\n                return;\r\n            case 'prerender-legacy':\r\n            case 'prerender-ppr':\r\n            case 'request':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\r\n    // don't need to do anything here because the entire page is already dynamic\r\n    // or it's static and it should not throw or postpone here.\r\n    if (store.forceDynamic || store.forceStatic) return;\r\n    if (store.dynamicShouldError) {\r\n        throw Object.defineProperty(new StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E553\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender-ppr':\r\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\r\n            case 'prerender-legacy':\r\n                workUnitStore.revalidate = 0;\r\n                // We aren't prerendering, but we are generating a static page. We need\r\n                // to bail out of static generation.\r\n                const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E550\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n                store.dynamicUsageDescription = expression;\r\n                store.dynamicUsageStack = err.stack;\r\n                throw err;\r\n            case 'request':\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    workUnitStore.usedDynamic = true;\r\n                }\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n}\r\n/**\r\n * This function is meant to be used when prerendering without cacheComponents or PPR.\r\n * When called during a build it will cause Next.js to consider the route as dynamic.\r\n *\r\n * @internal\r\n */ export function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\r\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\r\n    const err = Object.defineProperty(new DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E558\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    prerenderStore.revalidate = 0;\r\n    store.dynamicUsageDescription = expression;\r\n    store.dynamicUsageStack = err.stack;\r\n    throw err;\r\n}\r\n/**\r\n * This function should be used to track whether something dynamic happened even when\r\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\r\n * we still track whether dynamic APIs were accessed for helpful messaging\r\n *\r\n * @internal\r\n */ export function trackDynamicDataInDynamicRender(workUnitStore) {\r\n    switch(workUnitStore.type){\r\n        case 'cache':\r\n        case 'unstable-cache':\r\n            // Inside cache scopes, marking a scope as dynamic has no effect,\r\n            // because the outer cache scope creates a cache boundary. This is\r\n            // subtly different from reading a dynamic data source, which is\r\n            // forbidden inside a cache scope.\r\n            return;\r\n        case 'private-cache':\r\n            // A private cache scope is already dynamic by definition.\r\n            return;\r\n        case 'prerender':\r\n        case 'prerender-runtime':\r\n        case 'prerender-legacy':\r\n        case 'prerender-ppr':\r\n        case 'prerender-client':\r\n            break;\r\n        case 'request':\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                workUnitStore.usedDynamic = true;\r\n            }\r\n            break;\r\n        default:\r\n            workUnitStore;\r\n    }\r\n}\r\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\r\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\r\n    const error = createPrerenderInterruptedError(reason);\r\n    prerenderStore.controller.abort(error);\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            // When we aren't debugging, we don't need to create another error for the\r\n            // stack trace.\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n}\r\nexport function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\r\n    // It is important that we set this tracking value after aborting. Aborts are executed\r\n    // synchronously except for the case where you abort during render itself. By setting this\r\n    // value late we can use it to determine if any of the aborted tasks are the task that\r\n    // called the sync IO expression in the first place.\r\n    if (dynamicTracking) {\r\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\r\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\r\n        }\r\n    }\r\n}\r\nexport function trackSynchronousPlatformIOAccessInDev(requestStore) {\r\n    // We don't actually have a controller to abort but we do the semantic equivalent by\r\n    // advancing the request store out of prerender mode\r\n    requestStore.prerenderPhase = false;\r\n}\r\n/**\r\n * use this function when prerendering with cacheComponents. If we are doing a\r\n * prospective prerender we don't actually abort because we want to discover\r\n * all caches for the shell. If this is the actual prerender we do abort.\r\n *\r\n * This function accepts a prerenderStore but the caller should ensure we're\r\n * actually running in cacheComponents mode.\r\n *\r\n * @internal\r\n */ export function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\r\n    const prerenderSignal = prerenderStore.controller.signal;\r\n    if (prerenderSignal.aborted === false) {\r\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\r\n        // the error object when it isn't relevant to the aborting of the prerender however\r\n        // since we need the throw semantics regardless of whether we abort it is easier to land\r\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\r\n        // to ideal implementation\r\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\r\n        // It is important that we set this tracking value after aborting. Aborts are executed\r\n        // synchronously except for the case where you abort during render itself. By setting this\r\n        // value late we can use it to determine if any of the aborted tasks are the task that\r\n        // called the sync IO expression in the first place.\r\n        const dynamicTracking = prerenderStore.dynamicTracking;\r\n        if (dynamicTracking) {\r\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\r\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\r\n            }\r\n        }\r\n    }\r\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\r\n}\r\n/**\r\n * Use this function when dynamically prerendering with dynamicIO.\r\n * We don't want to error, because it's better to return something\r\n * (and we've already aborted the render at the point where the sync dynamic error occured),\r\n * but we should log an error server-side.\r\n * @internal\r\n */ export function warnOnSyncDynamicError(dynamicTracking) {\r\n    if (dynamicTracking.syncDynamicErrorWithStack) {\r\n        // the server did something sync dynamic, likely\r\n        // leading to an early termination of the prerender.\r\n        console.error(dynamicTracking.syncDynamicErrorWithStack);\r\n    }\r\n}\r\n// For now these implementations are the same so we just reexport\r\nexport const trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;\r\nexport function Postpone({ reason, route }) {\r\n    const prerenderStore = workUnitAsyncStorage.getStore();\r\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\r\n    postponeWithTracking(route, reason, dynamicTracking);\r\n}\r\nexport function postponeWithTracking(route, expression, dynamicTracking) {\r\n    assertPostpone();\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            // When we aren't debugging, we don't need to create another error for the\r\n            // stack trace.\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n    React.unstable_postpone(createPostponeReason(route, expression));\r\n}\r\nfunction createPostponeReason(route, expression) {\r\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\r\n}\r\nexport function isDynamicPostpone(err) {\r\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\r\n        return isDynamicPostponeReason(err.message);\r\n    }\r\n    return false;\r\n}\r\nfunction isDynamicPostponeReason(reason) {\r\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\r\n}\r\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\r\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E296\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\r\nfunction createPrerenderInterruptedError(message) {\r\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\r\n    return error;\r\n}\r\nexport function isPrerenderInterruptedError(error) {\r\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\r\n}\r\nexport function accessedDynamicData(dynamicAccesses) {\r\n    return dynamicAccesses.length > 0;\r\n}\r\nexport function consumeDynamicAccess(serverDynamic, clientDynamic) {\r\n    // We mutate because we only call this once we are no longer writing\r\n    // to the dynamicTrackingState and it's more efficient than creating a new\r\n    // array.\r\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\r\n    return serverDynamic.dynamicAccesses;\r\n}\r\nexport function formatDynamicAPIAccesses(dynamicAccesses) {\r\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\r\n        stack = stack.split('\\n')// Remove the \"Error: \" prefix from the first line of the stack trace as\r\n        // well as the first 4 lines of the stack trace which is the distance\r\n        // from the user code and the `new Error().stack` call.\r\n        .slice(4).filter((line)=>{\r\n            // Exclude Next.js internals from the stack trace.\r\n            if (line.includes('node_modules/next/')) {\r\n                return false;\r\n            }\r\n            // Exclude anonymous functions from the stack trace.\r\n            if (line.includes(' (<anonymous>)')) {\r\n                return false;\r\n            }\r\n            // Exclude Node.js internals from the stack trace.\r\n            if (line.includes(' (node:')) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }).join('\\n');\r\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\r\n    });\r\n}\r\nfunction assertPostpone() {\r\n    if (!hasPostpone) {\r\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E224\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\n/**\r\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\r\n * abort semantics slightly.\r\n */ export function createRenderInBrowserAbortSignal() {\r\n    const controller = new AbortController();\r\n    controller.abort(Object.defineProperty(new BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E721\",\r\n        enumerable: false,\r\n        configurable: true\r\n    }));\r\n    return controller.signal;\r\n}\r\n/**\r\n * In a prerender, we may end up with hanging Promises as inputs due them\r\n * stalling on connection() or because they're loading dynamic data. In that\r\n * case we need to abort the encoding of arguments since they'll never complete.\r\n */ export function createHangingInputAbortSignal(workUnitStore) {\r\n    switch(workUnitStore.type){\r\n        case 'prerender':\r\n        case 'prerender-runtime':\r\n            const controller = new AbortController();\r\n            if (workUnitStore.cacheSignal) {\r\n                // If we have a cacheSignal it means we're in a prospective render. If\r\n                // the input we're waiting on is coming from another cache, we do want\r\n                // to wait for it so that we can resolve this cache entry too.\r\n                workUnitStore.cacheSignal.inputReady().then(()=>{\r\n                    controller.abort();\r\n                });\r\n            } else {\r\n                // Otherwise we're in the final render and we should already have all\r\n                // our caches filled.\r\n                // If the prerender uses stages, we have wait until the runtime stage,\r\n                // at which point all runtime inputs will be resolved.\r\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\r\n                //  even though they'd resolve in the next task.)\r\n                //\r\n                // We might still be waiting on some microtasks so we\r\n                // wait one tick before giving up. When we give up, we still want to\r\n                // render the content of this cache as deeply as we can so that we can\r\n                // suspend as deeply as possible in the tree or not at all if we don't\r\n                // end up waiting for the input.\r\n                const runtimeStagePromise = getRuntimeStagePromise(workUnitStore);\r\n                if (runtimeStagePromise) {\r\n                    runtimeStagePromise.then(()=>scheduleOnNextTick(()=>controller.abort()));\r\n                } else {\r\n                    scheduleOnNextTick(()=>controller.abort());\r\n                }\r\n            }\r\n            return controller.signal;\r\n        case 'prerender-client':\r\n        case 'prerender-ppr':\r\n        case 'prerender-legacy':\r\n        case 'request':\r\n        case 'cache':\r\n        case 'private-cache':\r\n        case 'unstable-cache':\r\n            return undefined;\r\n        default:\r\n            workUnitStore;\r\n    }\r\n}\r\nexport function annotateDynamicAccess(expression, prerenderStore) {\r\n    const dynamicTracking = prerenderStore.dynamicTracking;\r\n    if (dynamicTracking) {\r\n        dynamicTracking.dynamicAccesses.push({\r\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\r\n            expression\r\n        });\r\n    }\r\n}\r\nexport function useDynamicRouteParams(expression) {\r\n    const workStore = workAsyncStorage.getStore();\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workStore && workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender-client':\r\n            case 'prerender':\r\n                {\r\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                    if (fallbackParams && fallbackParams.size > 0) {\r\n                        // We are in a prerender with cacheComponents semantics. We are going to\r\n                        // hang here and never resolve. This will cause the currently\r\n                        // rendering component to effectively be a dynamic hole.\r\n                        React.use(makeHangingPromise(workUnitStore.renderSignal, workStore.route, expression));\r\n                    }\r\n                    break;\r\n                }\r\n            case 'prerender-ppr':\r\n                {\r\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                    if (fallbackParams && fallbackParams.size > 0) {\r\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\r\n                    }\r\n                    break;\r\n                }\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E771\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n                throw Object.defineProperty(new InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E745\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n            case 'unstable-cache':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n}\r\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\r\n// Common implicit body tags that React will treat as body when placed directly in html\r\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\r\n// Detects when RootLayoutBoundary (our framework marker component) appears\r\n// after Suspense in the component stack, indicating the root layout is wrapped\r\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\r\n//\r\n// Example matches:\r\n//   at Suspense (<anonymous>)\r\n//   at __next_root_layout_boundary__ (<anonymous>)\r\n//\r\n// Or with other components in between (but not body/html/implicit-body):\r\n//   at Suspense (<anonymous>)\r\n//   at SomeComponent (<anonymous>)\r\n//   at __next_root_layout_boundary__ (<anonymous>)\r\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\r\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\r\nexport function trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\r\n    if (hasOutletRegex.test(componentStack)) {\r\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\r\n        return;\r\n    } else if (hasMetadataRegex.test(componentStack)) {\r\n        dynamicValidation.hasDynamicMetadata = true;\r\n        return;\r\n    } else if (hasViewportRegex.test(componentStack)) {\r\n        dynamicValidation.hasDynamicViewport = true;\r\n        return;\r\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\r\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\r\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\r\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\r\n        dynamicValidation.hasAllowedDynamic = true;\r\n        dynamicValidation.hasSuspenseAboveBody = true;\r\n        return;\r\n    } else if (hasSuspenseRegex.test(componentStack)) {\r\n        // this error had a Suspense boundary above it so we don't need to report it as a source\r\n        // of disallowed\r\n        dynamicValidation.hasAllowedDynamic = true;\r\n        return;\r\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\r\n        // This task was the task that called the sync error.\r\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\r\n        return;\r\n    } else {\r\n        const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;\r\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\r\n        dynamicValidation.dynamicErrors.push(error);\r\n        return;\r\n    }\r\n}\r\n/**\r\n * In dev mode, we prefer using the owner stack, otherwise the provided\r\n * component stack is used.\r\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\r\n    const ownerStack = process.env.NODE_ENV !== 'production' && React.captureOwnerStack ? React.captureOwnerStack() : null;\r\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\r\n    return error;\r\n}\r\nexport var PreludeState = /*#__PURE__*/ function(PreludeState) {\r\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\r\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\r\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\r\n    return PreludeState;\r\n}({});\r\nexport function logDisallowedDynamicError(workStore, error) {\r\n    console.error(error);\r\n    if (!workStore.dev) {\r\n        if (workStore.hasReadableErrorStacks) {\r\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\r\n        } else {\r\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\r\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\r\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\r\n        }\r\n    }\r\n}\r\nexport function throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\r\n    if (prelude !== 0) {\r\n        if (dynamicValidation.hasSuspenseAboveBody) {\r\n            // This route has opted into allowing fully dynamic rendering\r\n            // by including a Suspense boundary above the body. In this case\r\n            // a lack of a shell is not considered disallowed so we simply return\r\n            return;\r\n        }\r\n        if (serverDynamic.syncDynamicErrorWithStack) {\r\n            // There is no shell and the server did something sync dynamic likely\r\n            // leading to an early termination of the prerender before the shell\r\n            // could be completed. We terminate the build/validating render.\r\n            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n        // We didn't have any sync bailouts but there may be user code which\r\n        // blocked the root. We would have captured these during the prerender\r\n        // and can log them here and then terminate the build/validating render\r\n        const dynamicErrors = dynamicValidation.dynamicErrors;\r\n        if (dynamicErrors.length > 0) {\r\n            for(let i = 0; i < dynamicErrors.length; i++){\r\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\r\n            }\r\n            throw new StaticGenBailoutError();\r\n        }\r\n        // If we got this far then the only other thing that could be blocking\r\n        // the root is dynamic Viewport. If this is dynamic then\r\n        // you need to opt into that by adding a Suspense boundary above the body\r\n        // to indicate your are ok with fully dynamic rendering.\r\n        if (dynamicValidation.hasDynamicViewport) {\r\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n        if (prelude === 1) {\r\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\r\n            // We still adhere to the constraint that you must produce a shell but invite the\r\n            // user to report this as a bug in Next.js.\r\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n    } else {\r\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\r\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\r\n            throw new StaticGenBailoutError();\r\n        }\r\n    }\r\n}\r\nexport function delayUntilRuntimeStage(prerenderStore, result) {\r\n    if (prerenderStore.runtimeStagePromise) {\r\n        return prerenderStore.runtimeStagePromise.then(()=>result);\r\n    }\r\n    return result;\r\n}\r\n\r\n//# sourceMappingURL=dynamic-rendering.js.map","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE';\r\nexport class DynamicServerError extends Error {\r\n    constructor(description){\r\n        super(\"Dynamic server usage: \" + description), this.description = description, this.digest = DYNAMIC_ERROR_CODE;\r\n    }\r\n}\r\nexport function isDynamicServerError(err) {\r\n    if (typeof err !== 'object' || err === null || !('digest' in err) || typeof err.digest !== 'string') {\r\n        return false;\r\n    }\r\n    return err.digest === DYNAMIC_ERROR_CODE;\r\n}\r\n\r\n//# sourceMappingURL=hooks-server-context.js.map","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT';\r\nexport class StaticGenBailoutError extends Error {\r\n    constructor(...args){\r\n        super(...args), this.code = NEXT_STATIC_GEN_BAILOUT;\r\n    }\r\n}\r\nexport function isStaticGenBailoutError(error) {\r\n    if (typeof error !== 'object' || error === null || !('code' in error)) {\r\n        return false;\r\n    }\r\n    return error.code === NEXT_STATIC_GEN_BAILOUT;\r\n}\r\n\r\n//# sourceMappingURL=static-generation-bailout.js.map","export function isHangingPromiseRejectionError(err) {\r\n    if (typeof err !== 'object' || err === null || !('digest' in err)) {\r\n        return false;\r\n    }\r\n    return err.digest === HANGING_PROMISE_REJECTION;\r\n}\r\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\r\nclass HangingPromiseRejectionError extends Error {\r\n    constructor(route, expression){\r\n        super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`), this.route = route, this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\r\n    }\r\n}\r\nconst abortListenersBySignal = new WeakMap();\r\n/**\r\n * This function constructs a promise that will never resolve. This is primarily\r\n * useful for cacheComponents where we use promise resolution timing to determine which\r\n * parts of a render can be included in a prerender.\r\n *\r\n * @internal\r\n */ export function makeHangingPromise(signal, route, expression) {\r\n    if (signal.aborted) {\r\n        return Promise.reject(new HangingPromiseRejectionError(route, expression));\r\n    } else {\r\n        const hangingPromise = new Promise((_, reject)=>{\r\n            const boundRejection = reject.bind(null, new HangingPromiseRejectionError(route, expression));\r\n            let currentListeners = abortListenersBySignal.get(signal);\r\n            if (currentListeners) {\r\n                currentListeners.push(boundRejection);\r\n            } else {\r\n                const listeners = [\r\n                    boundRejection\r\n                ];\r\n                abortListenersBySignal.set(signal, listeners);\r\n                signal.addEventListener('abort', ()=>{\r\n                    for(let i = 0; i < listeners.length; i++){\r\n                        listeners[i]();\r\n                    }\r\n                }, {\r\n                    once: true\r\n                });\r\n            }\r\n        });\r\n        // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\r\n        // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\r\n        // your own promise out of it you'll need to ensure you handle the error when it rejects.\r\n        hangingPromise.catch(ignoreReject);\r\n        return hangingPromise;\r\n    }\r\n}\r\nfunction ignoreReject() {}\r\nexport function makeDevtoolsIOAwarePromise(underlying) {\r\n    // in React DevTools if we resolve in a setTimeout we will observe\r\n    // the promise resolution as something that can suspend a boundary or root.\r\n    return new Promise((resolve)=>{\r\n        // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\r\n        setTimeout(()=>{\r\n            resolve(underlying);\r\n        }, 0);\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=dynamic-rendering-utils.js.map","/**\r\n * Schedules a function to be called on the next tick after the other promises\r\n * have been resolved.\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleOnNextTick = (cb)=>{\r\n    // We use Promise.resolve().then() here so that the operation is scheduled at\r\n    // the end of the promise job queue, we then add it to the next process tick\r\n    // to ensure it's evaluated afterwards.\r\n    //\r\n    // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\r\n    //\r\n    Promise.resolve().then(()=>{\r\n        if (process.env.NEXT_RUNTIME === 'edge') {\r\n            setTimeout(cb, 0);\r\n        } else {\r\n            process.nextTick(cb);\r\n        }\r\n    });\r\n};\r\n/**\r\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\r\n * `setImmediate` is not available (like in the Edge runtime).\r\n *\r\n * @param cb the function to schedule\r\n */ export const scheduleImmediate = (cb)=>{\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        setTimeout(cb, 0);\r\n    } else {\r\n        setImmediate(cb);\r\n    }\r\n};\r\n/**\r\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\r\n * will be the next task but if you await it you can at least be sure that the current task is over and\r\n * most usefully that the entire microtask queue of the current task has been emptied.\r\n */ export function atLeastOneTask() {\r\n    return new Promise((resolve)=>scheduleImmediate(resolve));\r\n}\r\n/**\r\n * This utility function is extracted to make it easier to find places where we are doing\r\n * specific timing tricks to try to schedule work after React has rendered. This is especially\r\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\r\n * schedule work when you might expect that something like setImmediate would do the trick.\r\n *\r\n * Long term we should switch to the node versions of React rendering when possible and then\r\n * update this to use setImmediate rather than setTimeout\r\n */ export function waitAtLeastOneReactRenderTask() {\r\n    if (process.env.NEXT_RUNTIME === 'edge') {\r\n        return new Promise((r)=>setTimeout(r, 0));\r\n    } else {\r\n        return new Promise((r)=>setImmediate(r));\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=scheduler.js.map","const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\r\nexport function isPostpone(error) {\r\n    return typeof error === 'object' && error !== null && error.$$typeof === REACT_POSTPONE_TYPE;\r\n}\r\n\r\n//# sourceMappingURL=is-postpone.js.map","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils';\r\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone';\r\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr';\r\nimport { isNextRouterError } from './is-next-router-error';\r\nimport { isDynamicPostpone } from '../../server/app-render/dynamic-rendering';\r\nimport { isDynamicServerError } from './hooks-server-context';\r\nexport function unstable_rethrow(error) {\r\n    if (isNextRouterError(error) || isBailoutToCSRError(error) || isDynamicServerError(error) || isDynamicPostpone(error) || isPostpone(error) || isHangingPromiseRejectionError(error)) {\r\n        throw error;\r\n    }\r\n    if (error instanceof Error && 'cause' in error) {\r\n        unstable_rethrow(error.cause);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=unstable-rethrow.server.js.map","import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { workAsyncStorage } from '../../server/app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../../server/app-render/work-unit-async-storage.external'\n\nexport function bailoutToClientRendering(reason: string): void | never {\n  const workStore = workAsyncStorage.getStore()\n\n  if (workStore?.forceStatic) return\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        throw new BailoutToCSRError(reason)\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n","let warnOnce = (_)=>{};\r\nif (process.env.NODE_ENV !== 'production') {\r\n    const warnings = new Set();\r\n    warnOnce = (msg)=>{\r\n        if (!warnings.has(msg)) {\r\n            console.warn(msg);\r\n        }\r\n        warnings.add(msg);\r\n    };\r\n}\r\nexport { warnOnce };\r\n\r\n//# sourceMappingURL=warn-once.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\n/**\r\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\r\n * fallback component for HTTP errors.\r\n *\r\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\r\n *\r\n * e.g. 404\r\n * 404 represents not found, and the fallback component pair contains the component and its styles.\r\n *\r\n */ import React, { useContext } from 'react';\r\nimport { useUntrackedPathname } from '../navigation-untracked';\r\nimport { HTTPAccessErrorStatus, getAccessFallbackHTTPStatus, getAccessFallbackErrorTypeByStatus, isHTTPAccessFallbackError } from './http-access-fallback';\r\nimport { warnOnce } from '../../../shared/lib/utils/warn-once';\r\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime';\r\nclass HTTPAccessFallbackErrorBoundary extends React.Component {\r\n    componentDidCatch() {\r\n        if (process.env.NODE_ENV === 'development' && this.props.missingSlots && this.props.missingSlots.size > 0 && // A missing children slot is the typical not-found case, so no need to warn\r\n        !this.props.missingSlots.has('children')) {\r\n            let warningMessage = 'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n';\r\n            const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(', ');\r\n            warningMessage += 'Missing slots: ' + formattedSlots;\r\n            warnOnce(warningMessage);\r\n        }\r\n    }\r\n    static getDerivedStateFromError(error) {\r\n        if (isHTTPAccessFallbackError(error)) {\r\n            const httpStatus = getAccessFallbackHTTPStatus(error);\r\n            return {\r\n                triggeredStatus: httpStatus\r\n            };\r\n        }\r\n        // Re-throw if error is not for 404\r\n        throw error;\r\n    }\r\n    static getDerivedStateFromProps(props, state) {\r\n        /**\r\n     * Handles reset of the error boundary when a navigation happens.\r\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\r\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\r\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\r\n     */ if (props.pathname !== state.previousPathname && state.triggeredStatus) {\r\n            return {\r\n                triggeredStatus: undefined,\r\n                previousPathname: props.pathname\r\n            };\r\n        }\r\n        return {\r\n            triggeredStatus: state.triggeredStatus,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n    render() {\r\n        const { notFound, forbidden, unauthorized, children } = this.props;\r\n        const { triggeredStatus } = this.state;\r\n        const errorComponents = {\r\n            [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\r\n            [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\r\n            [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized\r\n        };\r\n        if (triggeredStatus) {\r\n            const isNotFound = triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound;\r\n            const isForbidden = triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden;\r\n            const isUnauthorized = triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized;\r\n            // If there's no matched boundary in this layer, keep throwing the error by rendering the children\r\n            if (!(isNotFound || isForbidden || isUnauthorized)) {\r\n                return children;\r\n            }\r\n            return /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(\"meta\", {\r\n                        name: \"robots\",\r\n                        content: \"noindex\"\r\n                    }),\r\n                    process.env.NODE_ENV === 'development' && /*#__PURE__*/ _jsx(\"meta\", {\r\n                        name: \"boundary-next-error\",\r\n                        content: getAccessFallbackErrorTypeByStatus(triggeredStatus)\r\n                    }),\r\n                    errorComponents[triggeredStatus]\r\n                ]\r\n            });\r\n        }\r\n        return children;\r\n    }\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            triggeredStatus: undefined,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n}\r\nexport function HTTPAccessFallbackBoundary(param) {\r\n    let { notFound, forbidden, unauthorized, children } = param;\r\n    // When we're rendering the missing params shell, this will return null. This\r\n    // is because we won't be rendering any not found boundaries or error\r\n    // boundaries for the missing params shell. When this runs on the client\r\n    // (where these error can occur), we will get the correct pathname.\r\n    const pathname = useUntrackedPathname();\r\n    const missingSlots = useContext(MissingSlotContext);\r\n    const hasErrorFallback = !!(notFound || forbidden || unauthorized);\r\n    if (hasErrorFallback) {\r\n        return /*#__PURE__*/ _jsx(HTTPAccessFallbackErrorBoundary, {\r\n            pathname: pathname,\r\n            notFound: notFound,\r\n            forbidden: forbidden,\r\n            unauthorized: unauthorized,\r\n            missingSlots: missingSlots,\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=error-boundary.js.map","import { useContext } from 'react';\r\nimport { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime';\r\n/**\r\n * This checks to see if the current render has any unknown route parameters.\r\n * It's used to trigger a different render path in the error boundary.\r\n *\r\n * @returns true if there are any unknown route parameters, false otherwise\r\n */ function hasFallbackRouteParams() {\r\n    if (typeof window === 'undefined') {\r\n        // AsyncLocalStorage should not be included in the client bundle.\r\n        const { workUnitAsyncStorage } = require('../../server/app-render/work-unit-async-storage.external');\r\n        const workUnitStore = workUnitAsyncStorage.getStore();\r\n        if (!workUnitStore) return false;\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n                const fallbackParams = workUnitStore.fallbackRouteParams;\r\n                return fallbackParams ? fallbackParams.size > 0 : false;\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n            case 'prerender-runtime':\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * This returns a `null` value if there are any unknown route parameters, and\r\n * otherwise returns the pathname from the context. This is an alternative to\r\n * `usePathname` that is used in the error boundary to avoid rendering the\r\n * error boundary when there are unknown route parameters. This doesn't throw\r\n * when accessed with unknown route parameters.\r\n *\r\n * @returns\r\n *\r\n * @internal\r\n */ export function useUntrackedPathname() {\r\n    // If there are any unknown route parameters we would typically throw\r\n    // an error, but this internal method allows us to return a null value instead\r\n    // for components that do not propagate the pathname to the static shell (like\r\n    // the error boundary).\r\n    if (hasFallbackRouteParams()) {\r\n        return null;\r\n    }\r\n    // This shouldn't cause any issues related to conditional rendering because\r\n    // the environment will be consistent for the render.\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    return useContext(PathnameContext);\r\n}\r\n\r\n//# sourceMappingURL=navigation-untracked.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport { ACTION_SERVER_PATCH } from './router-reducer/router-reducer-types';\r\nimport React, { useContext, use, startTransition, Suspense, useDeferredValue } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from '../../shared/lib/app-router-context.shared-runtime';\r\nimport { fetchServerResponse } from './router-reducer/fetch-server-response';\r\nimport { unresolvedThenable } from './unresolved-thenable';\r\nimport { ErrorBoundary } from './error-boundary';\r\nimport { matchSegment } from './match-segments';\r\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll';\r\nimport { RedirectBoundary } from './redirect-boundary';\r\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary';\r\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key';\r\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree';\r\nimport { dispatchAppRouterAction } from './use-action-queue';\r\nimport { useRouterBFCache } from './bfcache';\r\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths';\r\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE ? require('react').unstable_Activity : null;\r\n/**\r\n * Add refetch marker to router state at the point of the current layout segment.\r\n * This ensures the response returned is not further down than the current layout segment.\r\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\r\n    if (segmentPathToWalk) {\r\n        const [segment, parallelRouteKey] = segmentPathToWalk;\r\n        const isLast = segmentPathToWalk.length === 2;\r\n        if (matchSegment(treeToRecreate[0], segment)) {\r\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\r\n                if (isLast) {\r\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\r\n                    return [\r\n                        treeToRecreate[0],\r\n                        {\r\n                            ...treeToRecreate[1],\r\n                            [parallelRouteKey]: [\r\n                                subTree[0],\r\n                                subTree[1],\r\n                                subTree[2],\r\n                                'refetch'\r\n                            ]\r\n                        }\r\n                    ];\r\n                }\r\n                return [\r\n                    treeToRecreate[0],\r\n                    {\r\n                        ...treeToRecreate[1],\r\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\r\n                    }\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return treeToRecreate;\r\n}\r\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\r\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\r\n/**\r\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\r\n */ function findDOMNode(instance) {\r\n    // Tree-shake for server bundle\r\n    if (typeof window === 'undefined') return null;\r\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\r\n    // We need to lazily reference it.\r\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\r\n    return internal_reactDOMfindDOMNode(instance);\r\n}\r\nconst rectProperties = [\r\n    'bottom',\r\n    'height',\r\n    'left',\r\n    'right',\r\n    'top',\r\n    'width',\r\n    'x',\r\n    'y'\r\n];\r\n/**\r\n * Check if a HTMLElement is hidden or fixed/sticky position\r\n */ function shouldSkipElement(element) {\r\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\r\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\r\n    // even though the actual page content is offscreen\r\n    if ([\r\n        'sticky',\r\n        'fixed'\r\n    ].includes(getComputedStyle(element).position)) {\r\n        if (process.env.NODE_ENV === 'development') {\r\n            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);\r\n        }\r\n        return true;\r\n    }\r\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\r\n    // because `offsetParent` doesn't consider document/body\r\n    const rect = element.getBoundingClientRect();\r\n    return rectProperties.every((item)=>rect[item] === 0);\r\n}\r\n/**\r\n * Check if the top corner of the HTMLElement is in the viewport.\r\n */ function topOfElementInViewport(element, viewportHeight) {\r\n    const rect = element.getBoundingClientRect();\r\n    return rect.top >= 0 && rect.top <= viewportHeight;\r\n}\r\n/**\r\n * Find the DOM node for a hash fragment.\r\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\r\n * If the hash fragment is an id, the page has to scroll to the element with that id.\r\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\r\n */ function getHashFragmentDomNode(hashFragment) {\r\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\r\n    if (hashFragment === 'top') {\r\n        return document.body;\r\n    }\r\n    var _document_getElementById;\r\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\r\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\r\n    document.getElementsByName(hashFragment)[0];\r\n}\r\nclass InnerScrollAndFocusHandler extends React.Component {\r\n    componentDidMount() {\r\n        this.handlePotentialScroll();\r\n    }\r\n    componentDidUpdate() {\r\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\r\n        if (this.props.focusAndScrollRef.apply) {\r\n            this.handlePotentialScroll();\r\n        }\r\n    }\r\n    render() {\r\n        return this.props.children;\r\n    }\r\n    constructor(...args){\r\n        super(...args), this.handlePotentialScroll = ()=>{\r\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\r\n            const { focusAndScrollRef, segmentPath } = this.props;\r\n            if (focusAndScrollRef.apply) {\r\n                // segmentPaths is an array of segment paths that should be scrolled to\r\n                // if the current segment path is not in the array, the scroll is not applied\r\n                // unless the array is empty, in which case the scroll is always applied\r\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {\r\n                    return;\r\n                }\r\n                let domNode = null;\r\n                const hashFragment = focusAndScrollRef.hashFragment;\r\n                if (hashFragment) {\r\n                    domNode = getHashFragmentDomNode(hashFragment);\r\n                }\r\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\r\n                // This already caused a bug where the first child was a <link/> in head.\r\n                if (!domNode) {\r\n                    domNode = findDOMNode(this);\r\n                }\r\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\r\n                if (!(domNode instanceof Element)) {\r\n                    return;\r\n                }\r\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\r\n                // If the element is skipped, try to select the next sibling and try again.\r\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        var _domNode_parentElement;\r\n                        if (((_domNode_parentElement = domNode.parentElement) == null ? void 0 : _domNode_parentElement.localName) === 'head') {\r\n                        // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\r\n                        // This is always a bug in Next.js and caused by React hoisting metadata.\r\n                        // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\r\n                        }\r\n                    }\r\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\r\n                    if (domNode.nextElementSibling === null) {\r\n                        return;\r\n                    }\r\n                    domNode = domNode.nextElementSibling;\r\n                }\r\n                // State is mutated to ensure that the focus and scroll is applied only once.\r\n                focusAndScrollRef.apply = false;\r\n                focusAndScrollRef.hashFragment = null;\r\n                focusAndScrollRef.segmentPaths = [];\r\n                disableSmoothScrollDuringRouteTransition(()=>{\r\n                    // In case of hash scroll, we only need to scroll the element into view\r\n                    if (hashFragment) {\r\n                        ;\r\n                        domNode.scrollIntoView();\r\n                        return;\r\n                    }\r\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\r\n                    // and it won't change during this function.\r\n                    const htmlElement = document.documentElement;\r\n                    const viewportHeight = htmlElement.clientHeight;\r\n                    // If the element's top edge is already in the viewport, exit early.\r\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\r\n                        return;\r\n                    }\r\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\r\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\r\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\r\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\r\n                    htmlElement.scrollTop = 0;\r\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\r\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\r\n                        // Scroll into view doesn't scroll horizontally by default when not needed\r\n                        ;\r\n                        domNode.scrollIntoView();\r\n                    }\r\n                }, {\r\n                    // We will force layout by querying domNode position\r\n                    dontForceLayout: true,\r\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\r\n                });\r\n                // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\r\n                focusAndScrollRef.onlyHashChange = false;\r\n                // Set focus on the element\r\n                domNode.focus();\r\n            }\r\n        };\r\n    }\r\n}\r\nfunction ScrollAndFocusHandler(param) {\r\n    let { segmentPath, children } = param;\r\n    const context = useContext(GlobalLayoutRouterContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E473\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(InnerScrollAndFocusHandler, {\r\n        segmentPath: segmentPath,\r\n        focusAndScrollRef: context.focusAndScrollRef,\r\n        children: children\r\n    });\r\n}\r\n/**\r\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\r\n */ function InnerLayoutRouter(param) {\r\n    let { tree, segmentPath, cacheNode, url } = param;\r\n    const context = useContext(GlobalLayoutRouterContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant global layout router not mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E473\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const { tree: fullTree } = context;\r\n    // `rsc` represents the renderable node for this segment.\r\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\r\n    // We should use that on initial render instead of `rsc`. Then we'll switch\r\n    // to `rsc` when the dynamic response streams in.\r\n    //\r\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\r\n    const resolvedPrefetchRsc = cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc;\r\n    // We use `useDeferredValue` to handle switching between the prefetched and\r\n    // final values. The second argument is returned on initial render, then it\r\n    // re-renders with the first argument.\r\n    const rsc = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc);\r\n    // `rsc` is either a React node or a promise for a React node, except we\r\n    // special case `null` to represent that this segment's data is missing. If\r\n    // it's a promise, we need to unwrap it so we can determine whether or not the\r\n    // data is missing.\r\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? use(rsc) : rsc;\r\n    if (!resolvedRsc) {\r\n        // The data for this segment is not available, and there's no pending\r\n        // navigation that will be able to fulfill it. We need to fetch more from\r\n        // the server and patch the cache.\r\n        // Check if there's already a pending request.\r\n        let lazyData = cacheNode.lazyData;\r\n        if (lazyData === null) {\r\n            /**\r\n       * Router state with refetch marker added\r\n       */ // TODO-APP: remove ''\r\n            const refetchTree = walkAddRefetch([\r\n                '',\r\n                ...segmentPath\r\n            ], fullTree);\r\n            const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree);\r\n            const navigatedAt = Date.now();\r\n            cacheNode.lazyData = lazyData = fetchServerResponse(new URL(url, location.origin), {\r\n                flightRouterState: refetchTree,\r\n                nextUrl: includeNextUrl ? context.nextUrl : null\r\n            }).then((serverResponse)=>{\r\n                startTransition(()=>{\r\n                    dispatchAppRouterAction({\r\n                        type: ACTION_SERVER_PATCH,\r\n                        previousTree: fullTree,\r\n                        serverResponse,\r\n                        navigatedAt\r\n                    });\r\n                });\r\n                return serverResponse;\r\n            });\r\n            // Suspend while waiting for lazyData to resolve\r\n            use(lazyData);\r\n        }\r\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\r\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\r\n        use(unresolvedThenable);\r\n    }\r\n    // If we get to this point, then we know we have something we can render.\r\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\r\n    /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {\r\n        value: {\r\n            parentTree: tree,\r\n            parentCacheNode: cacheNode,\r\n            parentSegmentPath: segmentPath,\r\n            // TODO-APP: overriding of url for parallel routes\r\n            url: url\r\n        },\r\n        children: resolvedRsc\r\n    });\r\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\r\n    return subtree;\r\n}\r\n/**\r\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\r\n * If no loading property is provided it renders the children without a suspense boundary.\r\n */ function LoadingBoundary(param) {\r\n    let { loading, children } = param;\r\n    // If loading is a promise, unwrap it. This happens in cases where we haven't\r\n    // yet received the loading data from the server  which includes whether or\r\n    // not this layout has a loading component at all.\r\n    //\r\n    // It's OK to suspend here instead of inside the fallback because this\r\n    // promise will resolve simultaneously with the data for the segment itself.\r\n    // So it will never suspend for longer than it would have if we didn't use\r\n    // a Suspense fallback at all.\r\n    let loadingModuleData;\r\n    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {\r\n        const promiseForLoading = loading;\r\n        loadingModuleData = use(promiseForLoading);\r\n    } else {\r\n        loadingModuleData = loading;\r\n    }\r\n    if (loadingModuleData) {\r\n        const loadingRsc = loadingModuleData[0];\r\n        const loadingStyles = loadingModuleData[1];\r\n        const loadingScripts = loadingModuleData[2];\r\n        return /*#__PURE__*/ _jsx(Suspense, {\r\n            fallback: /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    loadingStyles,\r\n                    loadingScripts,\r\n                    loadingRsc\r\n                ]\r\n            }),\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n/**\r\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\r\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\r\n */ export default function OuterLayoutRouter(param) {\r\n    let { parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries } = param;\r\n    const context = useContext(LayoutRouterContext);\r\n    if (!context) {\r\n        throw Object.defineProperty(new Error('invariant expected layout router to be mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E56\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    const { parentTree, parentCacheNode, parentSegmentPath, url } = context;\r\n    // Get the CacheNode for this segment by reading it from the parent segment's\r\n    // child map.\r\n    const parentParallelRoutes = parentCacheNode.parallelRoutes;\r\n    let segmentMap = parentParallelRoutes.get(parallelRouterKey);\r\n    // If the parallel router cache node does not exist yet, create it.\r\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\r\n    if (!segmentMap) {\r\n        segmentMap = new Map();\r\n        parentParallelRoutes.set(parallelRouterKey, segmentMap);\r\n    }\r\n    const parentTreeSegment = parentTree[0];\r\n    const segmentPath = parentSegmentPath === null ? // path. This has led to a bunch of special cases scattered throughout\r\n    // the code. We should clean this up.\r\n    [\r\n        parallelRouterKey\r\n    ] : parentSegmentPath.concat([\r\n        parentTreeSegment,\r\n        parallelRouterKey\r\n    ]);\r\n    // The \"state\" key of a segment is the one passed to React  it represents the\r\n    // identity of the UI tree. Whenever the state key changes, the tree is\r\n    // recreated and the state is reset. In the App Router model, search params do\r\n    // not cause state to be lost, so two segments with the same segment path but\r\n    // different search params should have the same state key.\r\n    //\r\n    // The \"cache\" key of a segment, however, *does* include the search params, if\r\n    // it's possible that the segment accessed the search params on the server.\r\n    // (This only applies to page segments; layout segments cannot access search\r\n    // params on the server.)\r\n    const activeTree = parentTree[1][parallelRouterKey];\r\n    const activeSegment = activeTree[0];\r\n    const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\r\n    ;\r\n    // At each level of the route tree, not only do we render the currently\r\n    // active segment  we also render the last N segments that were active at\r\n    // this level inside a hidden <Activity> boundary, to preserve their state\r\n    // if or when the user navigates to them again.\r\n    //\r\n    // bfcacheEntry is a linked list of FlightRouterStates.\r\n    let bfcacheEntry = useRouterBFCache(activeTree, activeStateKey);\r\n    let children = [];\r\n    do {\r\n        const tree = bfcacheEntry.tree;\r\n        const stateKey = bfcacheEntry.stateKey;\r\n        const segment = tree[0];\r\n        const cacheKey = createRouterCacheKey(segment);\r\n        // Read segment path from the parallel router cache node.\r\n        let cacheNode = segmentMap.get(cacheKey);\r\n        if (cacheNode === undefined) {\r\n            // When data is not available during rendering client-side we need to fetch\r\n            // it from the server.\r\n            const newLazyCacheNode = {\r\n                lazyData: null,\r\n                rsc: null,\r\n                prefetchRsc: null,\r\n                head: null,\r\n                prefetchHead: null,\r\n                parallelRoutes: new Map(),\r\n                loading: null,\r\n                navigatedAt: -1\r\n            };\r\n            // Flight data fetch kicked off during render and put into the cache.\r\n            cacheNode = newLazyCacheNode;\r\n            segmentMap.set(cacheKey, newLazyCacheNode);\r\n        }\r\n        /*\r\n    - Error boundary\r\n      - Only renders error boundary if error component is provided.\r\n      - Rendered for each segment to ensure they have their own error state.\r\n      - When gracefully degrade for bots, skip rendering error boundary.\r\n    - Loading boundary\r\n      - Only renders suspense boundary if loading components is provided.\r\n      - Rendered for each segment to ensure they have their own loading state.\r\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\r\n  */ let segmentBoundaryTriggerNode = null;\r\n        let segmentViewStateNode = null;\r\n        if (process.env.NODE_ENV !== 'production' && process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER) {\r\n            const { SegmentBoundaryTriggerNode, SegmentViewStateNode } = require('../../next-devtools/userspace/app/segment-explorer-node');\r\n            const pagePrefix = normalizeAppPath(url);\r\n            segmentViewStateNode = /*#__PURE__*/ _jsx(SegmentViewStateNode, {\r\n                page: pagePrefix\r\n            }, pagePrefix);\r\n            segmentBoundaryTriggerNode = /*#__PURE__*/ _jsx(_Fragment, {\r\n                children: /*#__PURE__*/ _jsx(SegmentBoundaryTriggerNode, {})\r\n            });\r\n        }\r\n        // TODO: The loading module data for a segment is stored on the parent, then\r\n        // applied to each of that parent segment's parallel route slots. In the\r\n        // simple case where there's only one parallel route (the `children` slot),\r\n        // this is no different from if the loading module data where stored on the\r\n        // child directly. But I'm not sure this actually makes sense when there are\r\n        // multiple parallel routes. It's not a huge issue because you always have\r\n        // the option to define a narrower loading boundary for a particular slot. But\r\n        // this sort of smells like an implementation accident to me.\r\n        const loadingModuleData = parentCacheNode.loading;\r\n        let child = /*#__PURE__*/ _jsxs(TemplateContext.Provider, {\r\n            value: /*#__PURE__*/ _jsxs(ScrollAndFocusHandler, {\r\n                segmentPath: segmentPath,\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(ErrorBoundary, {\r\n                        errorComponent: error,\r\n                        errorStyles: errorStyles,\r\n                        errorScripts: errorScripts,\r\n                        children: /*#__PURE__*/ _jsx(LoadingBoundary, {\r\n                            loading: loadingModuleData,\r\n                            children: /*#__PURE__*/ _jsx(HTTPAccessFallbackBoundary, {\r\n                                notFound: notFound,\r\n                                forbidden: forbidden,\r\n                                unauthorized: unauthorized,\r\n                                children: /*#__PURE__*/ _jsxs(RedirectBoundary, {\r\n                                    children: [\r\n                                        /*#__PURE__*/ _jsx(InnerLayoutRouter, {\r\n                                            url: url,\r\n                                            tree: tree,\r\n                                            cacheNode: cacheNode,\r\n                                            segmentPath: segmentPath\r\n                                        }),\r\n                                        segmentBoundaryTriggerNode\r\n                                    ]\r\n                                })\r\n                            })\r\n                        })\r\n                    }),\r\n                    segmentViewStateNode\r\n                ]\r\n            }),\r\n            children: [\r\n                templateStyles,\r\n                templateScripts,\r\n                template\r\n            ]\r\n        }, stateKey);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            const { SegmentStateProvider } = require('../../next-devtools/userspace/app/segment-explorer-node');\r\n            child = /*#__PURE__*/ _jsxs(SegmentStateProvider, {\r\n                children: [\r\n                    child,\r\n                    segmentViewBoundaries\r\n                ]\r\n            }, stateKey);\r\n        }\r\n        if (process.env.__NEXT_ROUTER_BF_CACHE) {\r\n            child = /*#__PURE__*/ _jsx(Activity, {\r\n                mode: stateKey === activeStateKey ? 'visible' : 'hidden',\r\n                children: child\r\n            }, stateKey);\r\n        }\r\n        children.push(child);\r\n        bfcacheEntry = bfcacheEntry.next;\r\n    }while (bfcacheEntry !== null);\r\n    return children;\r\n}\r\n\r\n//# sourceMappingURL=layout-router.js.map","const basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\r\nconst pathname = \"\" + basePath + \"/__nextjs_source-map\";\r\nexport const findSourceMapURL = process.env.NODE_ENV === 'development' ? function findSourceMapURL(filename) {\r\n    if (filename === '') {\r\n        return null;\r\n    }\r\n    if (filename.startsWith(document.location.origin) && filename.includes('/_next/static')) {\r\n        // This is a request for a client chunk. This can only happen when\r\n        // using Turbopack. In this case, since we control how those source\r\n        // maps are generated, we can safely assume that the sourceMappingURL\r\n        // is relative to the filename, with an added `.map` extension. The\r\n        // browser can just request this file, and it gets served through the\r\n        // normal dev server, without the need to route this through\r\n        // the `/__nextjs_source-map` dev middleware.\r\n        return \"\" + filename + \".map\";\r\n    }\r\n    const url = new URL(pathname, document.location.origin);\r\n    url.searchParams.set('filename', filename);\r\n    return url.href;\r\n} : undefined;\r\n\r\n//# sourceMappingURL=app-find-source-map-url.js.map","// This gets assigned as a side-effect during app initialization. Because it\r\n// represents the build used to create the JS bundle, it should never change\r\n// after being set, so we store it in a global variable.\r\n//\r\n// When performing RSC requests, if the incoming data has a different build ID,\r\n// we perform an MPA navigation/refresh to load the updated build and ensure\r\n// that the client and server in sync.\r\n// Starts as an empty string. In practice, because setAppBuildId is called\r\n// during initialization before hydration starts, this will always get\r\n// reassigned to the actual build ID before it's ever needed by a navigation.\r\n// If for some reasons it didn't, due to a bug or race condition, then on\r\n// navigation the build comparision would fail and trigger an MPA navigation.\r\nlet globalBuildId = '';\r\nexport function setAppBuildId(buildId) {\r\n    globalBuildId = buildId;\r\n}\r\nexport function getAppBuildId() {\r\n    return globalBuildId;\r\n}\r\n\r\n//# sourceMappingURL=app-build-id.js.map","'use client';\r\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param';\r\nimport { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_SEGMENT_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_URL, NEXT_RSC_UNION_QUERY } from '../app-router-headers';\r\n/**\r\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\r\n * support custom headers. This helps avoid caching conflicts by making each request unique.\r\n *\r\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\r\n * to create a unique URL that forces a fresh request.\r\n *\r\n * Example:\r\n * URL before: https://example.com/path?query=1\r\n * URL after: https://example.com/path?query=1&_rsc=abc123\r\n *\r\n * Note: This function mutates the input URL directly and does not return anything.\r\n *\r\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\r\n * headers approach entirely and just use search params.\r\n */ export const setCacheBustingSearchParam = (url, headers)=>{\r\n    const uniqueCacheKey = computeCacheBustingSearchParam(headers[NEXT_ROUTER_PREFETCH_HEADER], headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[NEXT_ROUTER_STATE_TREE_HEADER], headers[NEXT_URL]);\r\n    setCacheBustingSearchParamWithHash(url, uniqueCacheKey);\r\n};\r\n/**\r\n * Sets a cache-busting search parameter on a URL using a provided hash value.\r\n *\r\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\r\n * a pre-computed hash instead of computing it from headers.\r\n *\r\n * Example:\r\n * URL before: https://example.com/path?query=1\r\n * hash: \"abc123\"\r\n * URL after: https://example.com/path?query=1&_rsc=abc123\r\n *\r\n * If the hash is null, we will set `_rsc` search param without a value.\r\n * Like this: https://example.com/path?query=1&_rsc\r\n *\r\n * Note: This function mutates the input URL directly and does not return anything.\r\n */ export const setCacheBustingSearchParamWithHash = (url, hash)=>{\r\n    /**\r\n   * Note that we intentionally do not use `url.searchParams.set` here:\r\n   *\r\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\r\n   * url.searchParams.set('_rsc', 'abc123');\r\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\r\n   *                                                                             ^ <--- this is causing confusion\r\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\r\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\r\n   * logic below.\r\n   */ const existingSearch = url.search;\r\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\r\n    // Always remove any existing cache busting param and add a fresh one to ensure\r\n    // we have the correct value based on current request headers\r\n    const pairs = rawQuery.split('&').filter((pair)=>pair && !pair.startsWith(\"\" + NEXT_RSC_UNION_QUERY + \"=\"));\r\n    if (hash.length > 0) {\r\n        pairs.push(NEXT_RSC_UNION_QUERY + \"=\" + hash);\r\n    } else {\r\n        pairs.push(\"\" + NEXT_RSC_UNION_QUERY);\r\n    }\r\n    url.search = pairs.length ? \"?\" + pairs.join('&') : '';\r\n};\r\n\r\n//# sourceMappingURL=set-cache-busting-search-param.js.map","'use client';\r\n// TODO: Explicitly import from client.browser\r\n// eslint-disable-next-line import/no-extraneous-dependencies\r\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client';\r\nimport { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE_HEADER, NEXT_RSC_UNION_QUERY, NEXT_URL, RSC_HEADER, RSC_CONTENT_TYPE_HEADER, NEXT_HMR_REFRESH_HEADER, NEXT_DID_POSTPONE_HEADER, NEXT_ROUTER_STALE_TIME_HEADER } from '../app-router-headers';\r\nimport { callServer } from '../../app-call-server';\r\nimport { findSourceMapURL } from '../../app-find-source-map-url';\r\nimport { PrefetchKind } from './router-reducer-types';\r\nimport { normalizeFlightData, prepareFlightRouterStateForRequest } from '../../flight-data-helpers';\r\nimport { getAppBuildId } from '../../app-build-id';\r\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param';\r\nimport { urlToUrlWithoutFlightMarker } from '../../route-params';\r\nconst createFromReadableStream = createFromReadableStreamBrowser;\r\nfunction doMpaNavigation(url) {\r\n    return {\r\n        flightData: urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString(),\r\n        canonicalUrl: undefined,\r\n        couldBeIntercepted: false,\r\n        prerendered: false,\r\n        postponed: false,\r\n        staleTime: -1\r\n    };\r\n}\r\nlet abortController = new AbortController();\r\nif (typeof window !== 'undefined') {\r\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\r\n    // reloading the page or performing hard navigations. This allows us to ignore\r\n    // what would otherwise be a thrown TypeError when the browser cancels the\r\n    // requests.\r\n    window.addEventListener('pagehide', ()=>{\r\n        abortController.abort();\r\n    });\r\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\r\n    // and the JavaScript execution context is restored by the browser.\r\n    window.addEventListener('pageshow', ()=>{\r\n        abortController = new AbortController();\r\n    });\r\n}\r\n/**\r\n * Fetch the flight data for the provided url. Takes in the current router state\r\n * to decide what to render server-side.\r\n */ export async function fetchServerResponse(url, options) {\r\n    const { flightRouterState, nextUrl, prefetchKind } = options;\r\n    const headers = {\r\n        // Enable flight response\r\n        [RSC_HEADER]: '1',\r\n        // Provide the current router state\r\n        [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(flightRouterState, options.isHmrRefresh)\r\n    };\r\n    /**\r\n   * Three cases:\r\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\r\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\r\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\r\n   */ if (prefetchKind === PrefetchKind.AUTO) {\r\n        headers[NEXT_ROUTER_PREFETCH_HEADER] = '1';\r\n    }\r\n    if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\r\n        headers[NEXT_HMR_REFRESH_HEADER] = '1';\r\n    }\r\n    if (nextUrl) {\r\n        headers[NEXT_URL] = nextUrl;\r\n    }\r\n    try {\r\n        var _res_headers_get;\r\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\r\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\r\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\r\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\r\n        const fetchPriority = prefetchKind ? prefetchKind === PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\r\n        if (process.env.NODE_ENV === 'production') {\r\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\r\n                // In \"output: export\" mode, we can't rely on headers to distinguish\r\n                // between HTML and RSC requests. Instead, we append an extra prefix\r\n                // to the request.\r\n                url = new URL(url);\r\n                if (url.pathname.endsWith('/')) {\r\n                    url.pathname += 'index.txt';\r\n                } else {\r\n                    url.pathname += '.txt';\r\n                }\r\n            }\r\n        }\r\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\r\n        const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url));\r\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\r\n        const contentType = res.headers.get('content-type') || '';\r\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(NEXT_URL));\r\n        const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER);\r\n        const staleTimeHeaderSeconds = res.headers.get(NEXT_ROUTER_STALE_TIME_HEADER);\r\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\r\n        let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER);\r\n        if (process.env.NODE_ENV === 'production') {\r\n            if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\r\n                if (!isFlightResponse) {\r\n                    isFlightResponse = contentType.startsWith('text/plain');\r\n                }\r\n            }\r\n        }\r\n        // If fetch returns something different than flight response handle it like a mpa navigation\r\n        // If the fetch was not 200, we also handle it like a mpa navigation\r\n        if (!isFlightResponse || !res.ok || !res.body) {\r\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\r\n            if (url.hash) {\r\n                responseUrl.hash = url.hash;\r\n            }\r\n            return doMpaNavigation(responseUrl.toString());\r\n        }\r\n        // We may navigate to a page that requires a different Webpack runtime.\r\n        // In prod, every page will have the same Webpack runtime.\r\n        // In dev, the Webpack runtime is minimal for each page.\r\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\r\n        if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\r\n            await require('../../dev/hot-reloader/app/hot-reloader-app').waitForWebpackRuntimeHotUpdate();\r\n        }\r\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\r\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\r\n        const response = await createFromNextReadableStream(flightStream);\r\n        if (getAppBuildId() !== response.b) {\r\n            return doMpaNavigation(res.url);\r\n        }\r\n        return {\r\n            flightData: normalizeFlightData(response.f),\r\n            canonicalUrl: canonicalUrl,\r\n            couldBeIntercepted: interception,\r\n            prerendered: response.S,\r\n            postponed,\r\n            staleTime\r\n        };\r\n    } catch (err) {\r\n        if (!abortController.signal.aborted) {\r\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\r\n        }\r\n        // If fetch fails handle it like a mpa navigation\r\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\r\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\r\n        return {\r\n            flightData: url.toString(),\r\n            canonicalUrl: undefined,\r\n            couldBeIntercepted: false,\r\n            prerendered: false,\r\n            postponed: false,\r\n            staleTime: -1\r\n        };\r\n    }\r\n}\r\nexport async function createFetch(url, headers, fetchPriority, signal) {\r\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\r\n    // cache busting search param) from the request so they're\r\n    // maximally cacheable.\r\n    if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\r\n        headers['Next-Test-Fetch-Priority'] = fetchPriority;\r\n    }\r\n    if (process.env.NEXT_DEPLOYMENT_ID) {\r\n        headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID;\r\n    }\r\n    const fetchOptions = {\r\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\r\n        credentials: 'same-origin',\r\n        headers,\r\n        priority: fetchPriority || undefined,\r\n        signal\r\n    };\r\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\r\n    // search param to it. This should not leak outside of this function, so we\r\n    // track them separately.\r\n    let fetchUrl = new URL(url);\r\n    setCacheBustingSearchParam(fetchUrl, headers);\r\n    let browserResponse = await fetch(fetchUrl, fetchOptions);\r\n    // If the server responds with a redirect (e.g. 307), and the redirected\r\n    // location does not contain the cache busting search param set in the\r\n    // original request, the response is likely invalid  when following the\r\n    // redirect, the browser forwards the request headers, but since the cache\r\n    // busting search param is missing, the server will reject the request due to\r\n    // a mismatch.\r\n    //\r\n    // Ideally, we would be able to intercept the redirect response and perform it\r\n    // manually, instead of letting the browser automatically follow it, but this\r\n    // is not allowed by the fetch API.\r\n    //\r\n    // So instead, we must \"replay\" the redirect by fetching the new location\r\n    // again, but this time we'll append the cache busting search param to prevent\r\n    // a mismatch.\r\n    //\r\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\r\n    // custom status code, to prevent the browser from automatically following it.\r\n    //\r\n    // This does not affect Server Action-based redirects; those are encoded\r\n    // differently, as part of the Flight body. It only affects redirects that\r\n    // occur in a middleware or a third-party proxy.\r\n    let redirected = browserResponse.redirected;\r\n    if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\r\n        // This is to prevent a redirect loop. Same limit used by Chrome.\r\n        const MAX_REDIRECTS = 20;\r\n        for(let n = 0; n < MAX_REDIRECTS; n++){\r\n            if (!browserResponse.redirected) {\r\n                break;\r\n            }\r\n            const responseUrl = new URL(browserResponse.url, fetchUrl);\r\n            if (responseUrl.origin !== fetchUrl.origin) {\r\n                break;\r\n            }\r\n            if (responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) === fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)) {\r\n                break;\r\n            }\r\n            // The RSC request was redirected. Assume the response is invalid.\r\n            //\r\n            // Append the cache busting search param to the redirected URL and\r\n            // fetch again.\r\n            fetchUrl = new URL(responseUrl);\r\n            setCacheBustingSearchParam(fetchUrl, headers);\r\n            browserResponse = await fetch(fetchUrl, fetchOptions);\r\n            // We just performed a manual redirect, so this is now true.\r\n            redirected = true;\r\n        }\r\n    }\r\n    // Remove the cache busting search param from the response URL, to prevent it\r\n    // from leaking outside of this function.\r\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\r\n    responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY);\r\n    const rscResponse = {\r\n        url: responseUrl.href,\r\n        // This is true if any redirects occurred, either automatically by the\r\n        // browser, or manually by us. So it's different from\r\n        // `browserResponse.redirected`, which only tells us whether the browser\r\n        // followed a redirect, and only for the last response in the chain.\r\n        redirected,\r\n        // These can be copied from the last browser response we received. We\r\n        // intentionally only expose the subset of fields that are actually used\r\n        // elsewhere in the codebase.\r\n        ok: browserResponse.ok,\r\n        headers: browserResponse.headers,\r\n        body: browserResponse.body,\r\n        status: browserResponse.status\r\n    };\r\n    return rscResponse;\r\n}\r\nexport function createFromNextReadableStream(flightStream) {\r\n    return createFromReadableStream(flightStream, {\r\n        callServer,\r\n        findSourceMapURL\r\n    });\r\n}\r\nfunction createUnclosingPrefetchStream(originalFlightStream) {\r\n    // When PPR is enabled, prefetch streams may contain references that never\r\n    // resolve, because that's how we encode dynamic data access. In the decoded\r\n    // object returned by the Flight client, these are reified into hanging\r\n    // promises that suspend during render, which is effectively what we want.\r\n    // The UI resolves when it switches to the dynamic data stream\r\n    // (via useDeferredValue(dynamic, static)).\r\n    //\r\n    // However, the Flight implementation currently errors if the server closes\r\n    // the response before all the references are resolved. As a cheat to work\r\n    // around this, we wrap the original stream in a new stream that never closes,\r\n    // and therefore doesn't error.\r\n    const reader = originalFlightStream.getReader();\r\n    return new ReadableStream({\r\n        async pull (controller) {\r\n            while(true){\r\n                const { done, value } = await reader.read();\r\n                if (!done) {\r\n                    // Pass to the target stream and keep consuming the Flight response\r\n                    // from the server.\r\n                    controller.enqueue(value);\r\n                    continue;\r\n                }\r\n                // The server stream has closed. Exit, but intentionally do not close\r\n                // the target stream.\r\n                return;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=fetch-server-response.js.map","const workAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/work-async-storage.external').workAsyncStorage : undefined;\r\n// if we are revalidating we want to re-throw the error so the\r\n// function crashes so we can maintain our previous cache\r\n// instead of caching the error page\r\nexport function HandleISRError(param) {\r\n    let { error } = param;\r\n    if (workAsyncStorage) {\r\n        const store = workAsyncStorage.getStore();\r\n        if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {\r\n            console.error(error);\r\n            throw error;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n//# sourceMappingURL=handle-isr-error.js.map","'use client';\r\nimport { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport React from 'react';\r\nimport { useUntrackedPathname } from './navigation-untracked';\r\nimport { isNextRouterError } from './is-next-router-error';\r\nimport { handleHardNavError } from './nav-failure-handler';\r\nimport { HandleISRError } from './handle-isr-error';\r\nimport { isBot } from '../../shared/lib/router/utils/is-bot';\r\nconst isBotUserAgent = typeof window !== 'undefined' && isBot(window.navigator.userAgent);\r\nexport class ErrorBoundaryHandler extends React.Component {\r\n    static getDerivedStateFromError(error) {\r\n        if (isNextRouterError(error)) {\r\n            // Re-throw if an expected internal Next.js router error occurs\r\n            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\r\n            throw error;\r\n        }\r\n        return {\r\n            error\r\n        };\r\n    }\r\n    static getDerivedStateFromProps(props, state) {\r\n        const { error } = state;\r\n        // if we encounter an error while\r\n        // a navigation is pending we shouldn't render\r\n        // the error boundary and instead should fallback\r\n        // to a hard navigation to attempt recovering\r\n        if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\r\n            if (error && handleHardNavError(error)) {\r\n                // clear error so we don't render anything\r\n                return {\r\n                    error: null,\r\n                    previousPathname: props.pathname\r\n                };\r\n            }\r\n        }\r\n        /**\r\n     * Handles reset of the error boundary when a navigation happens.\r\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\r\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\r\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\r\n     */ if (props.pathname !== state.previousPathname && state.error) {\r\n            return {\r\n                error: null,\r\n                previousPathname: props.pathname\r\n            };\r\n        }\r\n        return {\r\n            error: state.error,\r\n            previousPathname: props.pathname\r\n        };\r\n    }\r\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\r\n    render() {\r\n        //When it's bot request, segment level error boundary will keep rendering the children,\r\n        // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\r\n        if (this.state.error && !isBotUserAgent) {\r\n            return /*#__PURE__*/ _jsxs(_Fragment, {\r\n                children: [\r\n                    /*#__PURE__*/ _jsx(HandleISRError, {\r\n                        error: this.state.error\r\n                    }),\r\n                    this.props.errorStyles,\r\n                    this.props.errorScripts,\r\n                    /*#__PURE__*/ _jsx(this.props.errorComponent, {\r\n                        error: this.state.error,\r\n                        reset: this.reset\r\n                    })\r\n                ]\r\n            });\r\n        }\r\n        return this.props.children;\r\n    }\r\n    constructor(props){\r\n        super(props), this.reset = ()=>{\r\n            this.setState({\r\n                error: null\r\n            });\r\n        };\r\n        this.state = {\r\n            error: null,\r\n            previousPathname: this.props.pathname\r\n        };\r\n    }\r\n}\r\n/**\r\n * Handles errors through `getDerivedStateFromError`.\r\n * Renders the provided error component and provides a way to `reset` the error boundary state.\r\n */ /**\r\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\r\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\r\n */ export function ErrorBoundary(param) {\r\n    let { errorComponent, errorStyles, errorScripts, children } = param;\r\n    // When we're rendering the missing params shell, this will return null. This\r\n    // is because we won't be rendering any not found boundaries or error\r\n    // boundaries for the missing params shell. When this runs on the client\r\n    // (where these errors can occur), we will get the correct pathname.\r\n    const pathname = useUntrackedPathname();\r\n    if (errorComponent) {\r\n        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {\r\n            pathname: pathname,\r\n            errorComponent: errorComponent,\r\n            errorStyles: errorStyles,\r\n            errorScripts: errorScripts,\r\n            children: children\r\n        });\r\n    }\r\n    return /*#__PURE__*/ _jsx(_Fragment, {\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=error-boundary.js.map","import { warnOnce } from '../../utils/warn-once';\r\n/**\r\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\r\n * This css change will be reverted after the function finishes.\r\n */ export function disableSmoothScrollDuringRouteTransition(fn, options) {\r\n    if (options === void 0) options = {};\r\n    // if only the hash is changed, we don't need to disable smooth scrolling\r\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\r\n    if (options.onlyHashChange) {\r\n        fn();\r\n        return;\r\n    }\r\n    const htmlElement = document.documentElement;\r\n    const hasDataAttribute = htmlElement.dataset.scrollBehavior === 'smooth';\r\n    // Since this is a breaking change, this is temporarily flagged\r\n    // and will be false by default.\r\n    // In the next major (v16), this will be automatically enabled\r\n    if (process.env.__NEXT_OPTIMIZE_ROUTER_SCROLL) {\r\n        if (!hasDataAttribute) {\r\n            // No smooth scrolling configured, run directly without style manipulation\r\n            fn();\r\n            return;\r\n        }\r\n    } else {\r\n        // Old behavior: always manipulate styles, but warn about upcoming change\r\n        // Warn if smooth scrolling is detected but no data attribute is present\r\n        if (process.env.NODE_ENV === 'development' && !hasDataAttribute && getComputedStyle(htmlElement).scrollBehavior === 'smooth') {\r\n            warnOnce('Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, ' + 'Next.js will no longer automatically disable smooth scrolling during route transitions. ' + 'To prepare for this change, add `data-scroll-behavior=\"smooth\"` to your <html> element. ' + 'Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');\r\n        }\r\n    }\r\n    // Proceed with temporarily disabling smooth scrolling\r\n    const existing = htmlElement.style.scrollBehavior;\r\n    htmlElement.style.scrollBehavior = 'auto';\r\n    if (!options.dontForceLayout) {\r\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\r\n        // Otherwise it will not pickup the change in scrollBehavior\r\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\r\n        htmlElement.getClientRects();\r\n    }\r\n    fn();\r\n    htmlElement.style.scrollBehavior = existing;\r\n}\r\n\r\n//# sourceMappingURL=disable-smooth-scroll.js.map","import { RedirectStatusCode } from './redirect-status-code';\r\nimport { RedirectType, isRedirectError, REDIRECT_ERROR_CODE } from './redirect-error';\r\nconst actionAsyncStorage = typeof window === 'undefined' ? require('../../server/app-render/action-async-storage.external').actionAsyncStorage : undefined;\r\nexport function getRedirectError(url, type, statusCode) {\r\n    if (statusCode === void 0) statusCode = RedirectStatusCode.TemporaryRedirect;\r\n    const error = Object.defineProperty(new Error(REDIRECT_ERROR_CODE), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = REDIRECT_ERROR_CODE + \";\" + type + \";\" + url + \";\" + statusCode + \";\";\r\n    return error;\r\n}\r\n/**\r\n * This function allows you to redirect the user to another URL. It can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\r\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\r\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\r\n *\r\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\r\n */ export function redirect(/** The URL to redirect to */ url, type) {\r\n    var _actionAsyncStorage_getStore;\r\n    type != null ? type : type = (actionAsyncStorage == null ? void 0 : (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == null ? void 0 : _actionAsyncStorage_getStore.isAction) ? RedirectType.push : RedirectType.replace;\r\n    throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect);\r\n}\r\n/**\r\n * This function allows you to redirect the user to another URL. It can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\r\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\r\n *\r\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\r\n */ export function permanentRedirect(/** The URL to redirect to */ url, type) {\r\n    if (type === void 0) type = RedirectType.replace;\r\n    throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect);\r\n}\r\nexport function getURLFromRedirectError(error) {\r\n    if (!isRedirectError(error)) return null;\r\n    // Slices off the beginning of the digest that contains the code and the\r\n    // separating ';'.\r\n    return error.digest.split(';').slice(2, -2).join(';');\r\n}\r\nexport function getRedirectTypeFromError(error) {\r\n    if (!isRedirectError(error)) {\r\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E260\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return error.digest.split(';', 2)[1];\r\n}\r\nexport function getRedirectStatusCodeFromError(error) {\r\n    if (!isRedirectError(error)) {\r\n        throw Object.defineProperty(new Error('Not a redirect error'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E260\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return Number(error.digest.split(';').at(-2));\r\n}\r\n\r\n//# sourceMappingURL=redirect.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n/**\r\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `notFound()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\r\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\r\n *\r\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\r\n */ const DIGEST = \"\" + HTTP_ERROR_FALLBACK_ERROR_CODE + \";404\";\r\nexport function notFound() {\r\n    // eslint-disable-next-line no-throw-literal\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=not-found.js.map","/** @internal */ class ReadonlyURLSearchParamsError extends Error {\r\n    constructor(){\r\n        super('Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams');\r\n    }\r\n}\r\nclass ReadonlyURLSearchParams extends URLSearchParams {\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ append() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ delete() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ set() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n    /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ sort() {\r\n        throw new ReadonlyURLSearchParamsError();\r\n    }\r\n}\r\nexport function unstable_isUnrecognizedActionError() {\r\n    throw Object.defineProperty(new Error('`unstable_isUnrecognizedActionError` can only be used on the client.'), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E776\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nexport { redirect, permanentRedirect } from './redirect';\r\nexport { RedirectType } from './redirect-error';\r\nexport { notFound } from './not-found';\r\nexport { forbidden } from './forbidden';\r\nexport { unauthorized } from './unauthorized';\r\nexport { unstable_rethrow } from './unstable-rethrow';\r\nexport { ReadonlyURLSearchParams };\r\n\r\n//# sourceMappingURL=navigation.react-server.js.map","'use client';\r\nimport { jsx as _jsx } from \"react/jsx-runtime\";\r\nimport React, { useEffect } from 'react';\r\nimport { useRouter } from './navigation';\r\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect';\r\nimport { RedirectType, isRedirectError } from './redirect-error';\r\nfunction HandleRedirect(param) {\r\n    let { redirect, reset, redirectType } = param;\r\n    const router = useRouter();\r\n    useEffect(()=>{\r\n        React.startTransition(()=>{\r\n            if (redirectType === RedirectType.push) {\r\n                router.push(redirect, {});\r\n            } else {\r\n                router.replace(redirect, {});\r\n            }\r\n            reset();\r\n        });\r\n    }, [\r\n        redirect,\r\n        redirectType,\r\n        reset,\r\n        router\r\n    ]);\r\n    return null;\r\n}\r\nexport class RedirectErrorBoundary extends React.Component {\r\n    static getDerivedStateFromError(error) {\r\n        if (isRedirectError(error)) {\r\n            const url = getURLFromRedirectError(error);\r\n            const redirectType = getRedirectTypeFromError(error);\r\n            return {\r\n                redirect: url,\r\n                redirectType\r\n            };\r\n        }\r\n        // Re-throw if error is not for redirect\r\n        throw error;\r\n    }\r\n    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\r\n    render() {\r\n        const { redirect, redirectType } = this.state;\r\n        if (redirect !== null && redirectType !== null) {\r\n            return /*#__PURE__*/ _jsx(HandleRedirect, {\r\n                redirect: redirect,\r\n                redirectType: redirectType,\r\n                reset: ()=>this.setState({\r\n                        redirect: null\r\n                    })\r\n            });\r\n        }\r\n        return this.props.children;\r\n    }\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            redirect: null,\r\n            redirectType: null\r\n        };\r\n    }\r\n}\r\nexport function RedirectBoundary(param) {\r\n    let { children } = param;\r\n    const router = useRouter();\r\n    return /*#__PURE__*/ _jsx(RedirectErrorBoundary, {\r\n        router: router,\r\n        children: children\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=redirect-boundary.js.map","export const RSC_HEADER = 'rsc';\r\nexport const ACTION_HEADER = 'next-action';\r\n// TODO: Instead of sending the full router state, we only need to send the\r\n// segment path. Saves bytes. Then we could also use this field for segment\r\n// prefetches, which also need to specify a particular segment.\r\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree';\r\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch';\r\n// This contains the path to the segment being prefetched.\r\n// TODO: If we change next-router-state-tree to be a segment path, we can use\r\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\r\n// be merged into a single enum.\r\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = 'next-router-segment-prefetch';\r\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh';\r\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__';\r\nexport const NEXT_URL = 'next-url';\r\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component';\r\nexport const FLIGHT_HEADERS = [\r\n    RSC_HEADER,\r\n    NEXT_ROUTER_STATE_TREE_HEADER,\r\n    NEXT_ROUTER_PREFETCH_HEADER,\r\n    NEXT_HMR_REFRESH_HEADER,\r\n    NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\r\n];\r\nexport const NEXT_RSC_UNION_QUERY = '_rsc';\r\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time';\r\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed';\r\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path';\r\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query';\r\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender';\r\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found';\r\n\r\n//# sourceMappingURL=app-router-headers.js.map","export function createHrefFromUrl(url, includeHash) {\r\n    if (includeHash === void 0) includeHash = true;\r\n    return url.pathname + url.search + (includeHash ? url.hash : '');\r\n}\r\n\r\n//# sourceMappingURL=create-href-from-url.js.map","export function isGroupSegment(segment) {\r\n    // Use array[0] for performant purpose\r\n    return segment[0] === '(' && segment.endsWith(')');\r\n}\r\nexport function isParallelRouteSegment(segment) {\r\n    return segment.startsWith('@') && segment !== '@children';\r\n}\r\nexport function addSearchParamsIfPageSegment(segment, searchParams) {\r\n    const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);\r\n    if (isPageSegment) {\r\n        const stringifiedQuery = JSON.stringify(searchParams);\r\n        return stringifiedQuery !== '{}' ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery : PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\nexport const PAGE_SEGMENT_KEY = '__PAGE__';\r\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__';\r\n\r\n//# sourceMappingURL=segment.js.map","export const matchSegment = (existingSegment, segment)=>{\r\n    // segment is either Array or string\r\n    if (typeof existingSegment === 'string') {\r\n        if (typeof segment === 'string') {\r\n            // Common case: segment is just a string\r\n            return existingSegment === segment;\r\n        }\r\n        return false;\r\n    }\r\n    if (typeof segment === 'string') {\r\n        return false;\r\n    }\r\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\r\n};\r\n\r\n//# sourceMappingURL=match-segments.js.map","export const ACTION_REFRESH = 'refresh';\r\nexport const ACTION_NAVIGATE = 'navigate';\r\nexport const ACTION_RESTORE = 'restore';\r\nexport const ACTION_SERVER_PATCH = 'server-patch';\r\nexport const ACTION_PREFETCH = 'prefetch';\r\nexport const ACTION_HMR_REFRESH = 'hmr-refresh';\r\nexport const ACTION_SERVER_ACTION = 'server-action';\r\n/**\r\n * PrefetchKind defines the type of prefetching that should be done.\r\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\r\n * - `full` - prefetch the page data fully.\r\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\r\n */ export var PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\r\n    PrefetchKind[\"AUTO\"] = \"auto\";\r\n    PrefetchKind[\"FULL\"] = \"full\";\r\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\r\n    return PrefetchKind;\r\n}({});\r\nexport var PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {\r\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\r\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\r\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\r\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\r\n    return PrefetchCacheEntryStatus;\r\n}({});\r\n\r\n//# sourceMappingURL=router-reducer-types.js.map","export function getSegmentValue(segment) {\r\n    return Array.isArray(segment) ? segment[1] : segment;\r\n}\r\n\r\n//# sourceMappingURL=get-segment-value.js.map","export class UnrecognizedActionError extends Error {\r\n    constructor(...args){\r\n        super(...args);\r\n        this.name = 'UnrecognizedActionError';\r\n    }\r\n}\r\n/**\r\n * Check whether a server action call failed because the server action was not recognized by the server.\r\n * This can happen if the client and the server are not from the same deployment.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * try {\r\n *   await myServerAction();\r\n * } catch (err) {\r\n *   if (unstable_isUnrecognizedActionError(err)) {\r\n *     // The client is from a different deployment than the server.\r\n *     // Reloading the page will fix this mismatch.\r\n *     window.alert(\"Please refresh the page and try again\");\r\n *     return;\r\n *   }\r\n * }\r\n * ```\r\n * */ export function unstable_isUnrecognizedActionError(error) {\r\n    return !!(error && typeof error === 'object' && error instanceof UnrecognizedActionError);\r\n}\r\n\r\n//# sourceMappingURL=unrecognized-action-error.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n// TODO: Add `forbidden` docs\r\n/**\r\n * @experimental\r\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `forbidden()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\r\n */ const DIGEST = \"\" + HTTP_ERROR_FALLBACK_ERROR_CODE + \";403\";\r\nexport function forbidden() {\r\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\r\n        throw Object.defineProperty(new Error(\"`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled.\"), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E488\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    // eslint-disable-next-line no-throw-literal\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=forbidden.js.map","import { HTTP_ERROR_FALLBACK_ERROR_CODE } from './http-access-fallback/http-access-fallback';\r\n// TODO: Add `unauthorized` docs\r\n/**\r\n * @experimental\r\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\r\n * within a route segment as well as inject a tag.\r\n *\r\n * `unauthorized()` can be used in\r\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\r\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\r\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\r\n *\r\n *\r\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\r\n */ const DIGEST = \"\" + HTTP_ERROR_FALLBACK_ERROR_CODE + \";401\";\r\nexport function unauthorized() {\r\n    if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\r\n        throw Object.defineProperty(new Error(\"`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled.\"), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E411\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    // eslint-disable-next-line no-throw-literal\r\n    const error = Object.defineProperty(new Error(DIGEST), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E394\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    error.digest = DIGEST;\r\n    throw error;\r\n}\r\n\r\n//# sourceMappingURL=unauthorized.js.map","import { HTML_LIMITED_BOT_UA_RE } from './html-bots';\r\n// Bot crawler that will spin up a headless browser and execute JS.\r\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\r\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\r\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\r\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;\r\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source;\r\nexport { HTML_LIMITED_BOT_UA_RE };\r\nfunction isDomBotUA(userAgent) {\r\n    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);\r\n}\r\nfunction isHtmlLimitedBotUA(userAgent) {\r\n    return HTML_LIMITED_BOT_UA_RE.test(userAgent);\r\n}\r\nexport function isBot(userAgent) {\r\n    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);\r\n}\r\nexport function getBotType(userAgent) {\r\n    if (isDomBotUA(userAgent)) {\r\n        return 'dom';\r\n    }\r\n    if (isHtmlLimitedBotUA(userAgent)) {\r\n        return 'html';\r\n    }\r\n    return undefined;\r\n}\r\n\r\n//# sourceMappingURL=is-bot.js.map","import { useState } from 'react';\r\n// When the flag is disabled, only track the currently active tree\r\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1;\r\n/**\r\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\r\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\r\n * tracks the last N param values that the router rendered for N.\r\n *\r\n * The result of this hook precisely determines the number and order of\r\n * trees that are rendered in parallel at their segment level.\r\n *\r\n * The purpose of this cache is to we can preserve the React and DOM state of\r\n * some number of inactive trees, by rendering them in an <Activity> boundary.\r\n * That means it would not make sense for the the lifetime of the cache to be\r\n * any longer than the lifetime of the React tree; e.g. if the hook were\r\n * unmounted, then the React tree would be, too. So, we use React state to\r\n * manage it.\r\n *\r\n * Note that we don't store the RSC data for the cache entries in this hook \r\n * the data for inactive segments is stored in the parent CacheNode, which\r\n * *does* have a longer lifetime than the React tree. This hook only determines\r\n * which of those trees should have their *state* preserved, by <Activity>.\r\n */ export function useRouterBFCache(activeTree, activeStateKey) {\r\n    // The currently active entry. The entries form a linked list, sorted in\r\n    // order of most recently active. This allows us to reuse parts of the list\r\n    // without cloning, unless there's a reordering or removal.\r\n    // TODO: Once we start tracking back/forward history at each route level,\r\n    // we should use the history order instead. In other words, when traversing\r\n    // to an existing entry as a result of a popstate event, we should maintain\r\n    // the existing order instead of moving it to the front of the list. I think\r\n    // an initial implementation of this could be to pass an incrementing id\r\n    // to history.pushState/replaceState, then use that here for ordering.\r\n    const [prevActiveEntry, setPrevActiveEntry] = useState(()=>{\r\n        const initialEntry = {\r\n            tree: activeTree,\r\n            stateKey: activeStateKey,\r\n            next: null\r\n        };\r\n        return initialEntry;\r\n    });\r\n    if (prevActiveEntry.tree === activeTree) {\r\n        // Fast path. The active tree hasn't changed, so we can reuse the\r\n        // existing state.\r\n        return prevActiveEntry;\r\n    }\r\n    // The route tree changed. Note that this doesn't mean that the tree changed\r\n    // *at this level*  the change may be due to a child route. Either way, we\r\n    // need to either add or update the router tree in the bfcache.\r\n    //\r\n    // The rest of the code looks more complicated than it actually is because we\r\n    // can't mutate the state in place; we have to copy-on-write.\r\n    // Create a new entry for the active cache key. This is the head of the new\r\n    // linked list.\r\n    const newActiveEntry = {\r\n        tree: activeTree,\r\n        stateKey: activeStateKey,\r\n        next: null\r\n    };\r\n    // We need to append the old list onto the new list. If the head of the new\r\n    // list was already present in the cache, then we'll need to clone everything\r\n    // that came before it. Then we can reuse the rest.\r\n    let n = 1;\r\n    let oldEntry = prevActiveEntry;\r\n    let clonedEntry = newActiveEntry;\r\n    while(oldEntry !== null && n < MAX_BF_CACHE_ENTRIES){\r\n        if (oldEntry.stateKey === activeStateKey) {\r\n            // Fast path. This entry in the old list that corresponds to the key that\r\n            // is now active. We've already placed a clone of this entry at the front\r\n            // of the new list. We can reuse the rest of the old list without cloning.\r\n            // NOTE: We don't need to worry about eviction in this case because we\r\n            // haven't increased the size of the cache, and we assume the max size\r\n            // is constant across renders. If we were to change it to a dynamic limit,\r\n            // then the implementation would need to account for that.\r\n            clonedEntry.next = oldEntry.next;\r\n            break;\r\n        } else {\r\n            // Clone the entry and append it to the list.\r\n            n++;\r\n            const entry = {\r\n                tree: oldEntry.tree,\r\n                stateKey: oldEntry.stateKey,\r\n                next: null\r\n            };\r\n            clonedEntry.next = entry;\r\n            clonedEntry = entry;\r\n        }\r\n        oldEntry = oldEntry.next;\r\n    }\r\n    setPrevActiveEntry(newActiveEntry);\r\n    return newActiveEntry;\r\n}\r\n\r\n//# sourceMappingURL=bfcache.js.map","import { hexHash } from '../../hash';\r\nexport function computeCacheBustingSearchParam(prefetchHeader, segmentPrefetchHeader, stateTreeHeader, nextUrlHeader) {\r\n    if ((prefetchHeader === undefined || prefetchHeader === '0') && segmentPrefetchHeader === undefined && stateTreeHeader === undefined && nextUrlHeader === undefined) {\r\n        return '';\r\n    }\r\n    return hexHash([\r\n        prefetchHeader || '0',\r\n        segmentPrefetchHeader || '0',\r\n        stateTreeHeader || '0',\r\n        nextUrlHeader || '0'\r\n    ].join(','));\r\n}\r\n\r\n//# sourceMappingURL=cache-busting-search-param.js.map","import { PAGE_SEGMENT_KEY } from '../segment';\r\nexport const ROOT_SEGMENT_REQUEST_KEY = '';\r\nexport const ROOT_SEGMENT_CACHE_KEY = '';\r\nexport function createSegmentRequestKeyPart(segment) {\r\n    if (typeof segment === 'string') {\r\n        if (segment.startsWith(PAGE_SEGMENT_KEY)) {\r\n            // The Flight Router State type sometimes includes the search params in\r\n            // the page segment. However, the Segment Cache tracks this as a separate\r\n            // key. So, we strip the search params here, and then add them back when\r\n            // the cache entry is turned back into a FlightRouterState. This is an\r\n            // unfortunate consequence of the FlightRouteState being used both as a\r\n            // transport type and as a cache key; we'll address this once more of the\r\n            // Segment Cache implementation has settled.\r\n            // TODO: We should hoist the search params out of the FlightRouterState\r\n            // type entirely, This is our plan for dynamic route params, too.\r\n            return PAGE_SEGMENT_KEY;\r\n        }\r\n        const safeName = // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\r\n        // But params typically don't include the leading slash. We should use\r\n        // a different encoding to avoid this special case.\r\n        segment === '/_not-found' ? '_not-found' : encodeToFilesystemAndURLSafeString(segment);\r\n        // Since this is not a dynamic segment, it's fully encoded. It does not\r\n        // need to be \"hydrated\" with a param value.\r\n        return safeName;\r\n    }\r\n    const name = segment[0];\r\n    const paramType = segment[2];\r\n    const safeName = encodeToFilesystemAndURLSafeString(name);\r\n    const encodedName = '$' + paramType + '$' + safeName;\r\n    return encodedName;\r\n}\r\nexport function appendSegmentRequestKeyPart(parentRequestKey, parallelRouteKey, childRequestKeyPart) {\r\n    // Aside from being filesystem safe, segment keys are also designed so that\r\n    // each segment and parallel route creates its own subdirectory. Roughly in\r\n    // the same shape as the source app directory. This is mostly just for easier\r\n    // debugging (you can open up the build folder and navigate the output); if\r\n    // we wanted to do we could just use a flat structure.\r\n    // Omit the parallel route key for children, since this is the most\r\n    // common case. Saves some bytes (and it's what the app directory does).\r\n    const slotKey = parallelRouteKey === 'children' ? childRequestKeyPart : \"@\" + encodeToFilesystemAndURLSafeString(parallelRouteKey) + \"/\" + childRequestKeyPart;\r\n    return parentRequestKey + '/' + slotKey;\r\n}\r\nexport function createSegmentCacheKeyPart(requestKeyPart, segment) {\r\n    if (typeof segment === 'string') {\r\n        return requestKeyPart;\r\n    }\r\n    const paramValue = segment[1];\r\n    const safeValue = encodeToFilesystemAndURLSafeString(paramValue);\r\n    return requestKeyPart + '$' + safeValue;\r\n}\r\nexport function appendSegmentCacheKeyPart(parentSegmentKey, parallelRouteKey, childCacheKeyPart) {\r\n    const slotKey = parallelRouteKey === 'children' ? childCacheKeyPart : \"@\" + encodeToFilesystemAndURLSafeString(parallelRouteKey) + \"/\" + childCacheKeyPart;\r\n    return parentSegmentKey + '/' + slotKey;\r\n}\r\n// Define a regex pattern to match the most common characters found in a route\r\n// param. It excludes anything that might not be cross-platform filesystem\r\n// compatible, like |. It does not need to be precise because the fallback is to\r\n// just base64url-encode the whole parameter, which is fine; we just don't do it\r\n// by default for compactness, and for easier debugging.\r\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/;\r\nfunction encodeToFilesystemAndURLSafeString(value) {\r\n    if (simpleParamValueRegex.test(value)) {\r\n        return value;\r\n    }\r\n    // If there are any unsafe characters, base64url-encode the entire value.\r\n    // We also add a ! prefix so it doesn't collide with the simple case.\r\n    const base64url = btoa(value).replace(/\\+/g, '-') // Replace '+' with '-'\r\n    .replace(/\\//g, '_') // Replace '/' with '_'\r\n    .replace(/=+$/, '') // Remove trailing '='\r\n    ;\r\n    return '!' + base64url;\r\n}\r\nexport function convertSegmentPathToStaticExportFilename(segmentPath) {\r\n    return \"__next\" + segmentPath.replace(/\\//g, '.') + \".txt\";\r\n}\r\n\r\n//# sourceMappingURL=segment-value-encoding.js.map","import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment';\r\nexport function createRouterCacheKey(segment, withoutSearchParameters) {\r\n    if (withoutSearchParameters === void 0) withoutSearchParameters = false;\r\n    // if the segment is an array, it means it's a dynamic segment\r\n    // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\r\n    if (Array.isArray(segment)) {\r\n        return segment[0] + \"|\" + segment[1] + \"|\" + segment[2];\r\n    }\r\n    // Page segments might have search parameters, ie __PAGE__?foo=bar\r\n    // When `withoutSearchParameters` is true, we only want to return the page segment\r\n    if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\r\n        return PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\n\r\n//# sourceMappingURL=create-router-cache-key.js.map","import { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes';\r\nexport function hasInterceptionRouteInCurrentTree(param) {\r\n    let [segment, parallelRoutes] = param;\r\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\r\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\r\n        return true;\r\n    }\r\n    // If segment is not an array, apply the existing string-based check\r\n    if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\r\n        return true;\r\n    }\r\n    // Iterate through parallelRoutes if they exist\r\n    if (parallelRoutes) {\r\n        for(const key in parallelRoutes){\r\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n//# sourceMappingURL=has-interception-route-in-current-tree.js.map","import React, { use } from 'react';\r\nimport { isThenable } from '../../shared/lib/is-thenable';\r\n// The app router state lives outside of React, so we can import the dispatch\r\n// method directly wherever we need it, rather than passing it around via props\r\n// or context.\r\nlet dispatch = null;\r\nexport function dispatchAppRouterAction(action) {\r\n    if (dispatch === null) {\r\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E668\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    dispatch(action);\r\n}\r\nexport function useActionQueue(actionQueue) {\r\n    const [state, setState] = React.useState(actionQueue.state);\r\n    // Because of a known issue that requires to decode Flight streams inside the\r\n    // render phase, we have to be a bit clever and assign the dispatch method to\r\n    // a module-level variable upon initialization. The useState hook in this\r\n    // module only exists to synchronize state that lives outside of React.\r\n    // Ideally, what we'd do instead is pass the state as a prop to root.render;\r\n    // this is conceptually how we're modeling the app router state, despite the\r\n    // weird implementation details.\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        const { useAppDevRenderingIndicator } = require('../../next-devtools/userspace/use-app-dev-rendering-indicator');\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        const appDevRenderingIndicator = useAppDevRenderingIndicator();\r\n        dispatch = (action)=>{\r\n            appDevRenderingIndicator(()=>{\r\n                actionQueue.dispatch(action, setState);\r\n            });\r\n        };\r\n    } else {\r\n        dispatch = (action)=>actionQueue.dispatch(action, setState);\r\n    }\r\n    return isThenable(state) ? use(state) : state;\r\n}\r\n\r\n//# sourceMappingURL=use-action-queue.js.map","import { useContext, useMemo } from 'react';\r\nimport { AppRouterContext, LayoutRouterContext } from '../../shared/lib/app-router-context.shared-runtime';\r\nimport { SearchParamsContext, PathnameContext, PathParamsContext } from '../../shared/lib/hooks-client-context.shared-runtime';\r\nimport { getSegmentValue } from './router-reducer/reducers/get-segment-value';\r\nimport { PAGE_SEGMENT_KEY, DEFAULT_SEGMENT_KEY } from '../../shared/lib/segment';\r\nimport { ReadonlyURLSearchParams } from './navigation.react-server';\r\nconst useDynamicRouteParams = typeof window === 'undefined' ? require('../../server/app-render/dynamic-rendering').useDynamicRouteParams : undefined;\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you *read* the current URL's search parameters.\r\n *\r\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useSearchParams } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *   const searchParams = useSearchParams()\r\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\r\n *   // ...\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\r\n */ // Client components API\r\nexport function useSearchParams() {\r\n    const searchParams = useContext(SearchParamsContext);\r\n    // In the case where this is `null`, the compat types added in\r\n    // `next-env.d.ts` will add a new overload that changes the return type to\r\n    // include `null`.\r\n    const readonlySearchParams = useMemo(()=>{\r\n        if (!searchParams) {\r\n            // When the router is not ready in pages, we won't have the search params\r\n            // available.\r\n            return null;\r\n        }\r\n        return new ReadonlyURLSearchParams(searchParams);\r\n    }, [\r\n        searchParams\r\n    ]);\r\n    if (typeof window === 'undefined') {\r\n        // AsyncLocalStorage should not be included in the client bundle.\r\n        const { bailoutToClientRendering } = require('./bailout-to-client-rendering');\r\n        // TODO-APP: handle dynamic = 'force-static' here and on the client\r\n        bailoutToClientRendering('useSearchParams()');\r\n    }\r\n    return readonlySearchParams;\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the current URL's pathname.\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { usePathname } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\r\n *  // ...\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\r\n */ // Client components API\r\nexport function usePathname() {\r\n    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('usePathname()');\r\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\r\n    // will add a new overload that changes the return type to include `null`.\r\n    return useContext(PathnameContext);\r\n}\r\n// Client components API\r\nexport { ServerInsertedHTMLContext, useServerInsertedHTML } from '../../shared/lib/server-inserted-html.shared-runtime';\r\n/**\r\n *\r\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useRouter } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *  const router = useRouter()\r\n *  // ...\r\n *  router.push('/dashboard') // Navigate to /dashboard\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\r\n */ // Client components API\r\nexport function useRouter() {\r\n    const router = useContext(AppRouterContext);\r\n    if (router === null) {\r\n        throw Object.defineProperty(new Error('invariant expected app router to be mounted'), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E238\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return router;\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read a route's dynamic params filled in by the current URL.\r\n *\r\n * @example\r\n * ```ts\r\n * \"use client\"\r\n * import { useParams } from 'next/navigation'\r\n *\r\n * export default function Page() {\r\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\r\n *   const { team } = useParams() // team === \"nextjs\"\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\r\n */ // Client components API\r\nexport function useParams() {\r\n    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useParams()');\r\n    return useContext(PathParamsContext);\r\n}\r\n/** Get the canonical parameters from the current level to the leaf node. */ // Client components API\r\nfunction getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {\r\n    if (first === void 0) first = true;\r\n    if (segmentPath === void 0) segmentPath = [];\r\n    let node;\r\n    if (first) {\r\n        // Use the provided parallel route key on the first parallel route\r\n        node = tree[1][parallelRouteKey];\r\n    } else {\r\n        // After first parallel route prefer children, if there's no children pick the first parallel route.\r\n        const parallelRoutes = tree[1];\r\n        var _parallelRoutes_children;\r\n        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];\r\n    }\r\n    if (!node) return segmentPath;\r\n    const segment = node[0];\r\n    let segmentValue = getSegmentValue(segment);\r\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\r\n        return segmentPath;\r\n    }\r\n    segmentPath.push(segmentValue);\r\n    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the active route segments **below** the Layout it is called from.\r\n *\r\n * @example\r\n * ```ts\r\n * 'use client'\r\n *\r\n * import { useSelectedLayoutSegments } from 'next/navigation'\r\n *\r\n * export default function ExampleClientComponent() {\r\n *   const segments = useSelectedLayoutSegments()\r\n *\r\n *   return (\r\n *     <ul>\r\n *       {segments.map((segment, index) => (\r\n *         <li key={index}>{segment}</li>\r\n *       ))}\r\n *     </ul>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\r\n */ // Client components API\r\nexport function useSelectedLayoutSegments(parallelRouteKey) {\r\n    if (parallelRouteKey === void 0) parallelRouteKey = 'children';\r\n    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegments()');\r\n    const context = useContext(LayoutRouterContext);\r\n    // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\r\n    if (!context) return null;\r\n    return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);\r\n}\r\n/**\r\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\r\n * that lets you read the active route segment **one level below** the Layout it is called from.\r\n *\r\n * @example\r\n * ```ts\r\n * 'use client'\r\n * import { useSelectedLayoutSegment } from 'next/navigation'\r\n *\r\n * export default function ExampleClientComponent() {\r\n *   const segment = useSelectedLayoutSegment()\r\n *\r\n *   return <p>Active segment: {segment}</p>\r\n * }\r\n * ```\r\n *\r\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\r\n */ // Client components API\r\nexport function useSelectedLayoutSegment(parallelRouteKey) {\r\n    if (parallelRouteKey === void 0) parallelRouteKey = 'children';\r\n    useDynamicRouteParams == null ? void 0 : useDynamicRouteParams('useSelectedLayoutSegment()');\r\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\r\n    if (!selectedLayoutSegments || selectedLayoutSegments.length === 0) {\r\n        return null;\r\n    }\r\n    const selectedLayoutSegment = parallelRouteKey === 'children' ? selectedLayoutSegments[0] : selectedLayoutSegments[selectedLayoutSegments.length - 1];\r\n    // if the default slot is showing, we return null since it's not technically \"selected\" (it's a fallback)\r\n    // and returning an internal value like `__DEFAULT__` would be confusing.\r\n    return selectedLayoutSegment === DEFAULT_SEGMENT_KEY ? null : selectedLayoutSegment;\r\n}\r\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error';\r\n// Shared components APIs\r\nexport { notFound, forbidden, unauthorized, redirect, permanentRedirect, RedirectType, ReadonlyURLSearchParams, unstable_rethrow } from './navigation.react-server';\r\n\r\n//# sourceMappingURL=navigation.js.map","import { normalizeAppPath } from './app-paths';\r\n// order matters here, the first match will be used\r\nexport const INTERCEPTION_ROUTE_MARKERS = [\r\n    '(..)(..)',\r\n    '(.)',\r\n    '(..)',\r\n    '(...)'\r\n];\r\nexport function isInterceptionRouteAppPath(path) {\r\n    // TODO-APP: add more serious validation\r\n    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;\r\n}\r\nexport function extractInterceptionRouteInformation(path) {\r\n    let interceptingRoute, marker, interceptedRoute;\r\n    for (const segment of path.split('/')){\r\n        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\r\n        if (marker) {\r\n            ;\r\n            [interceptingRoute, interceptedRoute] = path.split(marker, 2);\r\n            break;\r\n        }\r\n    }\r\n    if (!interceptingRoute || !marker || !interceptedRoute) {\r\n        throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>\"), \"__NEXT_ERROR_CODE\", {\r\n            value: \"E269\",\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\r\n    ;\r\n    switch(marker){\r\n        case '(.)':\r\n            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\r\n            if (interceptingRoute === '/') {\r\n                interceptedRoute = \"/\" + interceptedRoute;\r\n            } else {\r\n                interceptedRoute = interceptingRoute + '/' + interceptedRoute;\r\n            }\r\n            break;\r\n        case '(..)':\r\n            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\r\n            if (interceptingRoute === '/') {\r\n                throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Cannot use (..) marker at the root level, use (.) instead.\"), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E207\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');\r\n            break;\r\n        case '(...)':\r\n            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\r\n            interceptedRoute = '/' + interceptedRoute;\r\n            break;\r\n        case '(..)(..)':\r\n            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\r\n            const splitInterceptingRoute = interceptingRoute.split('/');\r\n            if (splitInterceptingRoute.length <= 2) {\r\n                throw Object.defineProperty(new Error(\"Invalid interception route: \" + path + \". Cannot use (..)(..) marker at the root level or one level up.\"), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E486\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            }\r\n            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');\r\n            break;\r\n        default:\r\n            throw Object.defineProperty(new Error('Invariant: unexpected marker'), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E112\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n    }\r\n    return {\r\n        interceptingRoute,\r\n        interceptedRoute\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=interception-routes.js.map","import { useEffect } from 'react';\r\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url';\r\nexport function handleHardNavError(error) {\r\n    if (error && typeof window !== 'undefined' && window.next.__pendingUrl && createHrefFromUrl(new URL(window.location.href)) !== createHrefFromUrl(window.next.__pendingUrl)) {\r\n        console.error(\"Error occurred during navigation, falling back to hard navigation\", error);\r\n        window.location.href = window.next.__pendingUrl.toString();\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function useNavFailureHandler() {\r\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\r\n        // this if is only for DCE of the feature flag not conditional\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        useEffect(()=>{\r\n            const uncaughtExceptionHandler = (evt)=>{\r\n                const error = 'reason' in evt ? evt.reason : evt.error;\r\n                // if we have an unhandled exception/rejection during\r\n                // a navigation we fall back to a hard navigation to\r\n                // attempt recovering to a good state\r\n                handleHardNavError(error);\r\n            };\r\n            window.addEventListener('unhandledrejection', uncaughtExceptionHandler);\r\n            window.addEventListener('error', uncaughtExceptionHandler);\r\n            return ()=>{\r\n                window.removeEventListener('error', uncaughtExceptionHandler);\r\n                window.removeEventListener('unhandledrejection', uncaughtExceptionHandler);\r\n            };\r\n        }, []);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=nav-failure-handler.js.map","/**\r\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\r\n */ export const unresolvedThenable = {\r\n    then: ()=>{}\r\n};\r\n\r\n//# sourceMappingURL=unresolved-thenable.js.map","import { addSearchParamsIfPageSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from '../shared/lib/segment';\r\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding';\r\nimport { NEXT_REWRITTEN_PATH_HEADER, NEXT_REWRITTEN_QUERY_HEADER, NEXT_RSC_UNION_QUERY } from './components/app-router-headers';\r\nexport function getRenderedSearch(response) {\r\n    // If the server performed a rewrite, the search params used to render the\r\n    // page will be different from the params in the request URL. In this case,\r\n    // the response will include a header that gives the rewritten search query.\r\n    const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER);\r\n    if (rewrittenQuery !== null) {\r\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\r\n    }\r\n    // If the header is not present, there was no rewrite, so we use the search\r\n    // query of the response URL.\r\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\r\n}\r\nexport function getRenderedPathname(response) {\r\n    // If the server performed a rewrite, the pathname used to render the\r\n    // page will be different from the pathname in the request URL. In this case,\r\n    // the response will include a header that gives the rewritten pathname.\r\n    const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER);\r\n    return rewrittenPath != null ? rewrittenPath : urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\r\n}\r\nexport function parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\r\n    // This needs to match the behavior in get-dynamic-param.ts.\r\n    switch(paramType){\r\n        // Catchalls\r\n        case 'c':\r\n        case 'ci':\r\n            {\r\n                // Catchalls receive all the remaining URL parts. If there are no\r\n                // remaining pathname parts, return an empty array.\r\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\r\n            }\r\n        // Optional catchalls\r\n        case 'oc':\r\n            {\r\n                // Optional catchalls receive all the remaining URL parts, unless this is\r\n                // the end of the pathname, in which case they return null.\r\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\r\n            }\r\n        // Dynamic\r\n        case 'd':\r\n        case 'di':\r\n            {\r\n                if (partIndex >= pathnameParts.length) {\r\n                    // The route tree expected there to be more parts in the URL than there\r\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\r\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\r\n                    // Should this be a hard error? During a prefetch, we can just abort.\r\n                    // During a client navigation, we could trigger a hard refresh. But if\r\n                    // it happens during initial render, we don't really have any\r\n                    // recovery options.\r\n                    return '';\r\n                }\r\n                return encodeURIComponent(pathnameParts[partIndex]);\r\n            }\r\n        default:\r\n            paramType;\r\n            return '';\r\n    }\r\n}\r\nexport function doesStaticSegmentAppearInURL(segment) {\r\n    // This is not a parameterized segment; however, we need to determine\r\n    // whether or not this segment appears in the URL. For example, this route\r\n    // groups do not appear in the URL, so they should be skipped. Any other\r\n    // special cases must be handled here.\r\n    // TODO: Consider encoding this directly into the router tree instead of\r\n    // inferring it on the client based on the segment type. Something like\r\n    // a `doesAppearInURL` flag in FlightRouterState.\r\n    if (segment === ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\r\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\r\n    // Otherwise, we wouldn't need this special case because pages are\r\n    // always leaf nodes.\r\n    // TODO: Investigate why the loader produces these fake page segments.\r\n    segment.startsWith(PAGE_SEGMENT_KEY) || // Route groups.\r\n    segment[0] === '(' && segment.endsWith(')') || segment === DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\r\n        return false;\r\n    } else {\r\n        // All other segment types appear in the URL\r\n        return true;\r\n    }\r\n}\r\nexport function getCacheKeyForDynamicParam(paramValue, renderedSearch) {\r\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\r\n    // unify the various implementations so that these are always computed on\r\n    // the client.\r\n    if (typeof paramValue === 'string') {\r\n        // TODO: Refactor or remove this helper function to accept a string rather\r\n        // than the whole segment type. Also we can probably just append the\r\n        // search string instead of turning it into JSON.\r\n        const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\r\n        return pageSegmentWithSearchParams;\r\n    } else if (paramValue === null) {\r\n        return '';\r\n    } else {\r\n        return paramValue.join('/');\r\n    }\r\n}\r\nexport function urlToUrlWithoutFlightMarker(url) {\r\n    const urlWithoutFlightParameters = new URL(url);\r\n    urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY);\r\n    if (process.env.NODE_ENV === 'production') {\r\n        if (process.env.__NEXT_CONFIG_OUTPUT === 'export' && urlWithoutFlightParameters.pathname.endsWith('.txt')) {\r\n            const { pathname } = urlWithoutFlightParameters;\r\n            const length = pathname.endsWith('/index.txt') ? 10 : 4;\r\n            // Slice off `/index.txt` or `.txt` from the end of the pathname\r\n            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);\r\n        }\r\n    }\r\n    return urlWithoutFlightParameters;\r\n}\r\nexport function getParamValueFromCacheKey(paramCacheKey, paramType) {\r\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\r\n    // into a value that can be passed to `useParams` and client components.\r\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\r\n    if (isCatchAll) {\r\n        // Catch-all param keys are a concatenation of the path segments.\r\n        // See equivalent logic in `getSelectedParams`.\r\n        // TODO: We should just pass the array directly, rather than concatenate\r\n        // it to a string and then split it back to an array. It needs to be an\r\n        // array in some places, like when passing a key React, but we can convert\r\n        // it at runtime in those places.\r\n        return paramCacheKey.split('/');\r\n    }\r\n    return paramCacheKey;\r\n}\r\n\r\n//# sourceMappingURL=route-params.js.map","import { startTransition } from 'react';\r\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types';\r\nimport { dispatchAppRouterAction } from './components/use-action-queue';\r\nexport async function callServer(actionId, actionArgs) {\r\n    return new Promise((resolve, reject)=>{\r\n        startTransition(()=>{\r\n            dispatchAppRouterAction({\r\n                type: ACTION_SERVER_ACTION,\r\n                actionId,\r\n                actionArgs,\r\n                resolve,\r\n                reject\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n//# sourceMappingURL=app-call-server.js.map","/**\r\n * For a given page path, this function ensures that there is a leading slash.\r\n * If there is not a leading slash, one is added, otherwise it is noop.\r\n */ export function ensureLeadingSlash(path) {\r\n    return path.startsWith('/') ? path : \"/\" + path;\r\n}\r\n\r\n//# sourceMappingURL=ensure-leading-slash.js.map","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\r\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\r\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\r\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\r\nexport const HTML_LIMITED_BOT_UA_RE = /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i;\r\n\r\n//# sourceMappingURL=html-bots.js.map","import { PAGE_SEGMENT_KEY } from '../shared/lib/segment';\r\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\r\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\r\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\r\n// the different ways we express `FlightSegmentPath`.\r\nexport function getFlightDataPartsFromPath(flightDataPath) {\r\n    // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\r\n    const flightDataPathLength = 4;\r\n    // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\r\n    const [tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);\r\n    // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\r\n    const segmentPath = flightDataPath.slice(0, -flightDataPathLength);\r\n    var _segmentPath_;\r\n    return {\r\n        // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\r\n        // to the start of the segment path in some places which makes it hard to use solely the segment path.\r\n        // Look for \"// TODO-APP: remove ''\" in the codebase.\r\n        pathToSegment: segmentPath.slice(0, -1),\r\n        segmentPath,\r\n        // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\r\n        // in which case we default to ''.\r\n        segment: (_segmentPath_ = segmentPath[segmentPath.length - 1]) != null ? _segmentPath_ : '',\r\n        tree,\r\n        seedData,\r\n        head,\r\n        isHeadPartial,\r\n        isRootRender: flightDataPath.length === flightDataPathLength\r\n    };\r\n}\r\nexport function getNextFlightSegmentPath(flightSegmentPath) {\r\n    // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\r\n    // to get the next segment path.\r\n    return flightSegmentPath.slice(2);\r\n}\r\nexport function normalizeFlightData(flightData) {\r\n    // FlightData can be a string when the server didn't respond with a proper flight response,\r\n    // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\r\n    if (typeof flightData === 'string') {\r\n        return flightData;\r\n    }\r\n    return flightData.map((flightDataPath)=>getFlightDataPartsFromPath(flightDataPath));\r\n}\r\n/**\r\n * This function is used to prepare the flight router state for the request.\r\n * It removes markers that are not needed by the server, and are purely used\r\n * for stashing state on the client.\r\n * @param flightRouterState - The flight router state to prepare.\r\n * @param isHmrRefresh - Whether this is an HMR refresh request.\r\n * @returns The prepared flight router state.\r\n */ export function prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {\r\n    // HMR requests need the complete, unmodified state for proper functionality\r\n    if (isHmrRefresh) {\r\n        return encodeURIComponent(JSON.stringify(flightRouterState));\r\n    }\r\n    return encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));\r\n}\r\n/**\r\n * Recursively strips client-only data from FlightRouterState while preserving\r\n * server-needed information for proper rendering decisions.\r\n */ function stripClientOnlyDataFromFlightRouterState(flightRouterState) {\r\n    const [segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;\r\n    // __PAGE__ segments are always fetched from the server, so there's\r\n    // no need to send them up\r\n    const cleanedSegment = stripSearchParamsFromPageSegment(segment);\r\n    // Recursively process parallel routes\r\n    const cleanedParallelRoutes = {};\r\n    for (const [key, childState] of Object.entries(parallelRoutes)){\r\n        cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);\r\n    }\r\n    const result = [\r\n        cleanedSegment,\r\n        cleanedParallelRoutes,\r\n        null,\r\n        shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null\r\n    ];\r\n    // Append optional fields if present\r\n    if (isRootLayout !== undefined) {\r\n        result[4] = isRootLayout;\r\n    }\r\n    if (hasLoadingBoundary !== undefined) {\r\n        result[5] = hasLoadingBoundary;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Strips search parameters from __PAGE__ segments to prevent sensitive\r\n * client-side data from being sent to the server.\r\n */ function stripSearchParamsFromPageSegment(segment) {\r\n    if (typeof segment === 'string' && segment.startsWith(PAGE_SEGMENT_KEY + '?')) {\r\n        return PAGE_SEGMENT_KEY;\r\n    }\r\n    return segment;\r\n}\r\n/**\r\n * Determines whether the refresh marker should be sent to the server\r\n * Client-only markers like 'refresh' are stripped, while server-needed markers\r\n * like 'refetch' and 'inside-shared-layout' are preserved.\r\n */ function shouldPreserveRefreshMarker(refreshMarker) {\r\n    return Boolean(refreshMarker && refreshMarker !== 'refresh');\r\n}\r\n\r\n//# sourceMappingURL=flight-data-helpers.js.map","/**\r\n * Check to see if a value is Thenable.\r\n *\r\n * @param promise the maybe-thenable value\r\n * @returns true if the value is thenable\r\n */ export function isThenable(promise) {\r\n    return promise !== null && typeof promise === 'object' && 'then' in promise && typeof promise.then === 'function';\r\n}\r\n\r\n//# sourceMappingURL=is-thenable.js.map","/**\r\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\r\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\r\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\r\n *\r\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\r\n */ export const unstable_rethrow = typeof window === 'undefined' ? require('./unstable-rethrow.server').unstable_rethrow : require('./unstable-rethrow.browser').unstable_rethrow;\r\n\r\n//# sourceMappingURL=unstable-rethrow.js.map","// http://www.cse.yorku.ca/~oz/hash.html\r\n// More specifically, 32-bit hash via djbxor\r\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\r\n// This is due to number type differences between rust for turbopack to js number types,\r\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\r\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\r\n// as can gaurantee determinstic output from 32bit hash.\r\nexport function djb2Hash(str) {\r\n    let hash = 5381;\r\n    for(let i = 0; i < str.length; i++){\r\n        const char = str.charCodeAt(i);\r\n        hash = (hash << 5) + hash + char & 0xffffffff;\r\n    }\r\n    return hash >>> 0;\r\n}\r\nexport function hexHash(str) {\r\n    return djb2Hash(str).toString(36).slice(0, 5);\r\n}\r\n\r\n//# sourceMappingURL=hash.js.map","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash';\r\nimport { isGroupSegment } from '../../segment';\r\n/**\r\n * Normalizes an app route so it represents the actual request path. Essentially\r\n * performing the following transformations:\r\n *\r\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\r\n * - `/(dashboard)/account/page` to `/account`\r\n * - `/user/[id]/page` to `/user/[id]`\r\n * - `/account/page` to `/account`\r\n * - `/page` to `/`\r\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\r\n * - `/(dashboard)/account/route` to `/account`\r\n * - `/user/[id]/route` to `/user/[id]`\r\n * - `/account/route` to `/account`\r\n * - `/route` to `/`\r\n * - `/` to `/`\r\n *\r\n * @param route the app route to normalize\r\n * @returns the normalized pathname\r\n */ export function normalizeAppPath(route) {\r\n    return ensureLeadingSlash(route.split('/').reduce((pathname, segment, index, segments)=>{\r\n        // Empty segments are ignored.\r\n        if (!segment) {\r\n            return pathname;\r\n        }\r\n        // Groups are ignored.\r\n        if (isGroupSegment(segment)) {\r\n            return pathname;\r\n        }\r\n        // Parallel segments are ignored.\r\n        if (segment[0] === '@') {\r\n            return pathname;\r\n        }\r\n        // The last segment (if it's a leaf) should be ignored.\r\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\r\n            return pathname;\r\n        }\r\n        return pathname + \"/\" + segment;\r\n    }, ''));\r\n}\r\n/**\r\n * Strips the `.rsc` extension if it's in the pathname.\r\n * Since this function is used on full urls it checks `?` for searchParams handling.\r\n */ export function normalizeRscURL(url) {\r\n    return url.replace(/\\.rsc($|\\?)/, // $1 ensures `?` is preserved\r\n    '$1');\r\n}\r\n\r\n//# sourceMappingURL=app-paths.js.map","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","import * as React from 'react';\r\nconst errorRef = {\r\n    current: null\r\n};\r\n// React.cache is currently only available in canary/experimental React channels.\r\nconst cache = typeof React.cache === 'function' ? React.cache : (fn)=>fn;\r\n// When Cache Components is enabled, we record these as errors so that they\r\n// are captured by the dev overlay as it's more critical to fix these\r\n// when enabled.\r\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS ? console.error : console.warn;\r\n// We don't want to dedupe across requests.\r\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\r\nconst flushCurrentErrorIfNew = cache(// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\r\n(key)=>{\r\n    try {\r\n        logErrorOrWarn(errorRef.current);\r\n    } finally{\r\n        errorRef.current = null;\r\n    }\r\n});\r\n/**\r\n * Creates a function that logs an error message that is deduped by the userland\r\n * callsite.\r\n * This requires no indirection between the call of this function and the userland\r\n * callsite i.e. there's only a single library frame above this.\r\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\r\n * Only use that for warnings need a fix independent of the callstack.\r\n *\r\n * @param getMessage\r\n * @returns\r\n */ export function createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\r\n    return function logDedupedError(...args) {\r\n        const message = getMessage(...args);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            var _stack;\r\n            const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\r\n            if (callStackFrames === undefined || callStackFrames.length < 4) {\r\n                logErrorOrWarn(message);\r\n            } else {\r\n                // Error:\r\n                //   logDedupedError\r\n                //   asyncApiBeingAccessedSynchronously\r\n                //   <userland callsite>\r\n                // TODO: This breaks if sourcemaps with ignore lists are enabled.\r\n                const key = callStackFrames[4];\r\n                errorRef.current = message;\r\n                flushCurrentErrorIfNew(key);\r\n            }\r\n        } else {\r\n            logErrorOrWarn(message);\r\n        }\r\n    };\r\n}\r\n\r\n//# sourceMappingURL=create-deduped-by-callsite-server-error-logger.js.map","// This regex will have fast negatives meaning valid identifiers may not pass\r\n// this test. However this is only used during static generation to provide hints\r\n// about why a page bailed out of some or all prerendering and we can use bracket notation\r\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\r\n// even if this would have been fine too `searchParams._`\r\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\r\nexport function describeStringPropertyAccess(target, prop) {\r\n    if (isDefinitelyAValidIdentifier.test(prop)) {\r\n        return \"`\" + target + \".\" + prop + \"`\";\r\n    }\r\n    return \"`\" + target + \"[\" + JSON.stringify(prop) + \"]`\";\r\n}\r\nexport function describeHasCheckingStringProperty(target, prop) {\r\n    const stringifiedProp = JSON.stringify(prop);\r\n    return \"`Reflect.has(\" + target + \", \" + stringifiedProp + \")`, `\" + stringifiedProp + \" in \" + target + \"`, or similar\";\r\n}\r\nexport const wellKnownProperties = new Set([\r\n    'hasOwnProperty',\r\n    'isPrototypeOf',\r\n    'propertyIsEnumerable',\r\n    'toString',\r\n    'valueOf',\r\n    'toLocaleString',\r\n    // Promise prototype\r\n    // fallthrough\r\n    'then',\r\n    'catch',\r\n    'finally',\r\n    // React Promise extension\r\n    // fallthrough\r\n    'status',\r\n    // React introspection\r\n    'displayName',\r\n    '_debugInfo',\r\n    // Common tested properties\r\n    // fallthrough\r\n    'toJSON',\r\n    '$$typeof',\r\n    '__esModule'\r\n]);\r\n\r\n//# sourceMappingURL=reflect-utils.js.map","export class ReflectAdapter {\r\n    static get(target, prop, receiver) {\r\n        const value = Reflect.get(target, prop, receiver);\r\n        if (typeof value === 'function') {\r\n            return value.bind(target);\r\n        }\r\n        return value;\r\n    }\r\n    static set(target, prop, value, receiver) {\r\n        return Reflect.set(target, prop, value, receiver);\r\n    }\r\n    static has(target, prop) {\r\n        return Reflect.has(target, prop);\r\n    }\r\n    static deleteProperty(target, prop) {\r\n        return Reflect.deleteProperty(target, prop);\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=reflect.js.map","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout';\r\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external';\r\nexport function throwWithStaticGenerationBailoutError(route, expression) {\r\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E576\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\r\n    throw Object.defineProperty(new StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E543\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nexport function throwForSearchParamsAccessInUseCache(workStore, constructorOpt) {\r\n    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \"searchParams\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E779\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Error.captureStackTrace(error, constructorOpt);\r\n    workStore.invalidDynamicUsageError ??= error;\r\n    throw error;\r\n}\r\nexport function isRequestAPICallableInsideAfter() {\r\n    const afterTaskStore = afterTaskAsyncStorage.getStore();\r\n    return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\r\n}\r\n\r\n//# sourceMappingURL=utils.js.map","import { ReflectAdapter } from '../web/spec-extension/adapters/reflect';\r\nimport { throwToInterruptStaticGeneration, postponeWithTracking, trackDynamicDataInDynamicRender, annotateDynamicAccess, trackSynchronousRequestDataAccessInDev, delayUntilRuntimeStage } from '../app-render/dynamic-rendering';\r\nimport { workUnitAsyncStorage, throwInvariantForMissingStore } from '../app-render/work-unit-async-storage.external';\r\nimport { InvariantError } from '../../shared/lib/invariant-error';\r\nimport { makeDevtoolsIOAwarePromise, makeHangingPromise } from '../dynamic-rendering-utils';\r\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger';\r\nimport { describeStringPropertyAccess, describeHasCheckingStringProperty, wellKnownProperties } from '../../shared/lib/utils/reflect-utils';\r\nimport { throwWithStaticGenerationBailoutErrorWithDynamicError, throwForSearchParamsAccessInUseCache } from './utils';\r\nexport function createSearchParamsFromClient(underlyingSearchParams, workStore) {\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E769\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createSearchParamsFromClient should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E739\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'request':\r\n                return createRenderSearchParams(underlyingSearchParams, workStore);\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\r\nexport const createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\r\nexport function createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n                return createStaticPrerenderSearchParams(workStore, workUnitStore);\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createServerSearchParamsForServerPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E747\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-runtime':\r\n                return createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore);\r\n            case 'request':\r\n                return createRenderSearchParams(underlyingSearchParams, workStore);\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\nexport function createPrerenderSearchParamsForClientPage(workStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    }\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n                // We're prerendering in a mode that aborts (cacheComponents) and should stall\r\n                // the promise to ensure the RSC side is considered dynamic\r\n                return makeHangingPromise(workUnitStore.renderSignal, workStore.route, '`searchParams`');\r\n            case 'prerender-runtime':\r\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E768\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                throw Object.defineProperty(new InvariantError('createPrerenderSearchParamsForClientPage should not be called in cache contexts.'), \"__NEXT_ERROR_CODE\", {\r\n                    value: \"E746\",\r\n                    enumerable: false,\r\n                    configurable: true\r\n                });\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n            case 'request':\r\n                return Promise.resolve({});\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n    throwInvariantForMissingStore();\r\n}\r\nfunction createStaticPrerenderSearchParams(workStore, prerenderStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    }\r\n    switch(prerenderStore.type){\r\n        case 'prerender':\r\n        case 'prerender-client':\r\n            // We are in a cacheComponents (PPR or otherwise) prerender\r\n            return makeHangingSearchParams(workStore, prerenderStore);\r\n        case 'prerender-ppr':\r\n        case 'prerender-legacy':\r\n            // We are in a legacy static generation and need to interrupt the\r\n            // prerender when search params are accessed.\r\n            return makeErroringExoticSearchParams(workStore, prerenderStore);\r\n        default:\r\n            return prerenderStore;\r\n    }\r\n}\r\nfunction createRuntimePrerenderSearchParams(underlyingSearchParams, workUnitStore) {\r\n    return delayUntilRuntimeStage(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedSearchParams(underlyingSearchParams) : makeUntrackedExoticSearchParams(underlyingSearchParams));\r\n}\r\nfunction createRenderSearchParams(underlyingSearchParams, workStore) {\r\n    if (workStore.forceStatic) {\r\n        // When using forceStatic we override all other logic and always just return an empty\r\n        // dictionary object.\r\n        return Promise.resolve({});\r\n    } else {\r\n        if (process.env.NODE_ENV === 'development') {\r\n            // Semantically we only need the dev tracking when running in `next dev`\r\n            // but since you would never use next dev with production NODE_ENV we use this\r\n            // as a proxy so we can statically exclude this code from production builds.\r\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\r\n                return makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\r\n            }\r\n            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\r\n        } else {\r\n            if (process.env.__NEXT_CACHE_COMPONENTS) {\r\n                return makeUntrackedSearchParams(underlyingSearchParams);\r\n            }\r\n            return makeUntrackedExoticSearchParams(underlyingSearchParams);\r\n        }\r\n    }\r\n}\r\nconst CachedSearchParams = new WeakMap();\r\nconst CachedSearchParamsForUseCache = new WeakMap();\r\nfunction makeHangingSearchParams(workStore, prerenderStore) {\r\n    const cachedSearchParams = CachedSearchParams.get(prerenderStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = makeHangingPromise(prerenderStore.renderSignal, workStore.route, '`searchParams`');\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it.\r\n                // We know it isn't a dynamic access because it can only be something\r\n                // that was previously written to the promise and thus not an underlying searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            switch(prop){\r\n                case 'then':\r\n                    {\r\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\r\n                        annotateDynamicAccess(expression, prerenderStore);\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n                case 'status':\r\n                    {\r\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\r\n                        annotateDynamicAccess(expression, prerenderStore);\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n                default:\r\n                    {\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n            }\r\n        }\r\n    });\r\n    CachedSearchParams.set(prerenderStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\nfunction makeErroringExoticSearchParams(workStore, prerenderStore) {\r\n    const cachedSearchParams = CachedSearchParams.get(workStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const underlyingSearchParams = {};\r\n    // For search params we don't construct a ReactPromise because we want to interrupt\r\n    // rendering on any property access that was not set from outside and so we only want\r\n    // to have properties like value and status if React sets them.\r\n    const promise = Promise.resolve(underlyingSearchParams);\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it.\r\n                // We know it isn't a dynamic access because it can only be something\r\n                // that was previously written to the promise and thus not an underlying searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            switch(prop){\r\n                case 'then':\r\n                    {\r\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\r\n                        if (workStore.dynamicShouldError) {\r\n                            throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                        } else if (prerenderStore.type === 'prerender-ppr') {\r\n                            // PPR Prerender (no cacheComponents)\r\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n                        } else {\r\n                            // Legacy Prerender\r\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n                        }\r\n                        return;\r\n                    }\r\n                case 'status':\r\n                    {\r\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\r\n                        if (workStore.dynamicShouldError) {\r\n                            throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                        } else if (prerenderStore.type === 'prerender-ppr') {\r\n                            // PPR Prerender (no cacheComponents)\r\n                            postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n                        } else {\r\n                            // Legacy Prerender\r\n                            throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n                        }\r\n                        return;\r\n                    }\r\n                default:\r\n                    {\r\n                        if (typeof prop === 'string' && !wellKnownProperties.has(prop)) {\r\n                            const expression = describeStringPropertyAccess('searchParams', prop);\r\n                            if (workStore.dynamicShouldError) {\r\n                                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                            } else if (prerenderStore.type === 'prerender-ppr') {\r\n                                // PPR Prerender (no cacheComponents)\r\n                                postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n                            } else {\r\n                                // Legacy Prerender\r\n                                throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n                            }\r\n                        }\r\n                        return ReflectAdapter.get(target, prop, receiver);\r\n                    }\r\n            }\r\n        },\r\n        has (target, prop) {\r\n            // We don't expect key checking to be used except for testing the existence of\r\n            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\r\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\r\n            // you are testing whether the searchParams has a 'then' property.\r\n            if (typeof prop === 'string') {\r\n                const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                if (workStore.dynamicShouldError) {\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n                } else if (prerenderStore.type === 'prerender-ppr') {\r\n                    // PPR Prerender (no cacheComponents)\r\n                    postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n                } else {\r\n                    // Legacy Prerender\r\n                    throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n                }\r\n                return false;\r\n            }\r\n            return ReflectAdapter.has(target, prop);\r\n        },\r\n        ownKeys () {\r\n            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\r\n            if (workStore.dynamicShouldError) {\r\n                throwWithStaticGenerationBailoutErrorWithDynamicError(workStore.route, expression);\r\n            } else if (prerenderStore.type === 'prerender-ppr') {\r\n                // PPR Prerender (no cacheComponents)\r\n                postponeWithTracking(workStore.route, expression, prerenderStore.dynamicTracking);\r\n            } else {\r\n                // Legacy Prerender\r\n                throwToInterruptStaticGeneration(expression, workStore, prerenderStore);\r\n            }\r\n        }\r\n    });\r\n    CachedSearchParams.set(workStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\n/**\r\n * This is a variation of `makeErroringExoticSearchParams` that always throws an\r\n * error on access, because accessing searchParams inside of `\"use cache\"` is\r\n * not allowed.\r\n */ export function makeErroringSearchParamsForUseCache(workStore) {\r\n    const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = Promise.resolve({});\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get: function get(target, prop, receiver) {\r\n            if (Object.hasOwn(promise, prop)) {\r\n                // The promise has this property directly. we must return it. We know it\r\n                // isn't a dynamic access because it can only be something that was\r\n                // previously written to the promise and thus not an underlying\r\n                // searchParam value\r\n                return ReflectAdapter.get(target, prop, receiver);\r\n            }\r\n            if (typeof prop === 'string' && (prop === 'then' || !wellKnownProperties.has(prop))) {\r\n                throwForSearchParamsAccessInUseCache(workStore, get);\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        has: function has(target, prop) {\r\n            // We don't expect key checking to be used except for testing the existence of\r\n            // searchParams so we make all has tests throw an error. this means that `promise.then`\r\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\r\n            // you are testing whether the searchParams has a 'then' property.\r\n            if (typeof prop === 'string' && (prop === 'then' || !wellKnownProperties.has(prop))) {\r\n                throwForSearchParamsAccessInUseCache(workStore, has);\r\n            }\r\n            return ReflectAdapter.has(target, prop);\r\n        },\r\n        ownKeys: function ownKeys() {\r\n            throwForSearchParamsAccessInUseCache(workStore, ownKeys);\r\n        }\r\n    });\r\n    CachedSearchParamsForUseCache.set(workStore, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams) {\r\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    // We don't use makeResolvedReactPromise here because searchParams\r\n    // supports copying with spread and we don't want to unnecessarily\r\n    // instrument the promise with spreadable properties of ReactPromise.\r\n    const promise = Promise.resolve(underlyingSearchParams);\r\n    CachedSearchParams.set(underlyingSearchParams, promise);\r\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\r\n        if (!wellKnownProperties.has(prop)) {\r\n            Object.defineProperty(promise, prop, {\r\n                get () {\r\n                    const workUnitStore = workUnitAsyncStorage.getStore();\r\n                    if (workUnitStore) {\r\n                        trackDynamicDataInDynamicRender(workUnitStore);\r\n                    }\r\n                    return underlyingSearchParams[prop];\r\n                },\r\n                set (value) {\r\n                    Object.defineProperty(promise, prop, {\r\n                        value,\r\n                        writable: true,\r\n                        enumerable: true\r\n                    });\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        }\r\n    });\r\n    return promise;\r\n}\r\nfunction makeUntrackedSearchParams(underlyingSearchParams) {\r\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const promise = Promise.resolve(underlyingSearchParams);\r\n    CachedSearchParams.set(underlyingSearchParams, promise);\r\n    return promise;\r\n}\r\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {\r\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const proxiedProperties = new Set();\r\n    const unproxiedProperties = [];\r\n    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\r\n    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\r\n    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\r\n    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\r\n    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\r\n    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\r\n    let promiseInitialized = false;\r\n    const proxiedUnderlying = new Proxy(underlyingSearchParams, {\r\n        get (target, prop, receiver) {\r\n            if (typeof prop === 'string' && promiseInitialized) {\r\n                if (store.dynamicShouldError) {\r\n                    const expression = describeStringPropertyAccess('searchParams', prop);\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\r\n                }\r\n                const workUnitStore = workUnitAsyncStorage.getStore();\r\n                if (workUnitStore) {\r\n                    trackDynamicDataInDynamicRender(workUnitStore);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        has (target, prop) {\r\n            if (typeof prop === 'string') {\r\n                if (store.dynamicShouldError) {\r\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                    throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\r\n                }\r\n            }\r\n            return Reflect.has(target, prop);\r\n        },\r\n        ownKeys (target) {\r\n            if (store.dynamicShouldError) {\r\n                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\r\n                throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\r\n            }\r\n            return Reflect.ownKeys(target);\r\n        }\r\n    });\r\n    // We don't use makeResolvedReactPromise here because searchParams\r\n    // supports copying with spread and we don't want to unnecessarily\r\n    // instrument the promise with spreadable properties of ReactPromise.\r\n    const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams);\r\n    promise.then(()=>{\r\n        promiseInitialized = true;\r\n    });\r\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\r\n        if (wellKnownProperties.has(prop)) {\r\n            // These properties cannot be shadowed because they need to be the\r\n            // true underlying value for Promises to work correctly at runtime\r\n            unproxiedProperties.push(prop);\r\n        } else {\r\n            proxiedProperties.add(prop);\r\n            Object.defineProperty(promise, prop, {\r\n                get () {\r\n                    return proxiedUnderlying[prop];\r\n                },\r\n                set (newValue) {\r\n                    Object.defineProperty(promise, prop, {\r\n                        value: newValue,\r\n                        writable: true,\r\n                        enumerable: true\r\n                    });\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        }\r\n    });\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (prop === 'then' && store.dynamicShouldError) {\r\n                const expression = '`searchParams.then`';\r\n                throwWithStaticGenerationBailoutErrorWithDynamicError(store.route, expression);\r\n            }\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeStringPropertyAccess('searchParams', prop);\r\n                    syncIODev(store.route, expression);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        set (target, prop, value, receiver) {\r\n            if (typeof prop === 'string') {\r\n                proxiedProperties.delete(prop);\r\n            }\r\n            return Reflect.set(target, prop, value, receiver);\r\n        },\r\n        has (target, prop) {\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                    syncIODev(store.route, expression);\r\n                }\r\n            }\r\n            return Reflect.has(target, prop);\r\n        },\r\n        ownKeys (target) {\r\n            const expression = '`Object.keys(searchParams)` or similar';\r\n            syncIODev(store.route, expression, unproxiedProperties);\r\n            return Reflect.ownKeys(target);\r\n        }\r\n    });\r\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\n// Similar to `makeDynamicallyTrackedExoticSearchParamsWithDevWarnings`, but\r\n// just logging the sync access without actually defining the search params on\r\n// the promise.\r\nfunction makeUntrackedSearchParamsWithDevWarnings(underlyingSearchParams, store) {\r\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\r\n    if (cachedSearchParams) {\r\n        return cachedSearchParams;\r\n    }\r\n    const proxiedProperties = new Set();\r\n    const unproxiedProperties = [];\r\n    const promise = makeDevtoolsIOAwarePromise(underlyingSearchParams);\r\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\r\n        if (wellKnownProperties.has(prop)) {\r\n            // These properties cannot be shadowed because they need to be the\r\n            // true underlying value for Promises to work correctly at runtime\r\n            unproxiedProperties.push(prop);\r\n        } else {\r\n            proxiedProperties.add(prop);\r\n        }\r\n    });\r\n    const proxiedPromise = new Proxy(promise, {\r\n        get (target, prop, receiver) {\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeStringPropertyAccess('searchParams', prop);\r\n                    warnForSyncAccess(store.route, expression);\r\n                }\r\n            }\r\n            return ReflectAdapter.get(target, prop, receiver);\r\n        },\r\n        set (target, prop, value, receiver) {\r\n            if (typeof prop === 'string') {\r\n                proxiedProperties.delete(prop);\r\n            }\r\n            return Reflect.set(target, prop, value, receiver);\r\n        },\r\n        has (target, prop) {\r\n            if (typeof prop === 'string') {\r\n                if (!wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\r\n                // the underlying searchParams.\r\n                Reflect.has(target, prop) === false)) {\r\n                    const expression = describeHasCheckingStringProperty('searchParams', prop);\r\n                    warnForSyncAccess(store.route, expression);\r\n                }\r\n            }\r\n            return Reflect.has(target, prop);\r\n        },\r\n        ownKeys (target) {\r\n            const expression = '`Object.keys(searchParams)` or similar';\r\n            warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);\r\n            return Reflect.ownKeys(target);\r\n        }\r\n    });\r\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\r\n    return proxiedPromise;\r\n}\r\nfunction syncIODev(route, expression, missingProperties) {\r\n    // In all cases we warn normally\r\n    if (missingProperties && missingProperties.length > 0) {\r\n        warnForIncompleteEnumeration(route, expression, missingProperties);\r\n    } else {\r\n        warnForSyncAccess(route, expression);\r\n    }\r\n    const workUnitStore = workUnitAsyncStorage.getStore();\r\n    if (workUnitStore) {\r\n        switch(workUnitStore.type){\r\n            case 'request':\r\n                if (workUnitStore.prerenderPhase === true) {\r\n                    // When we're rendering dynamically in dev, we need to advance out of\r\n                    // the Prerender environment when we read Request data synchronously.\r\n                    trackSynchronousRequestDataAccessInDev(workUnitStore);\r\n                }\r\n                break;\r\n            case 'prerender':\r\n            case 'prerender-client':\r\n            case 'prerender-runtime':\r\n            case 'prerender-ppr':\r\n            case 'prerender-legacy':\r\n            case 'cache':\r\n            case 'private-cache':\r\n            case 'unstable-cache':\r\n                break;\r\n            default:\r\n                workUnitStore;\r\n        }\r\n    }\r\n}\r\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(createSearchAccessError);\r\nconst warnForIncompleteEnumeration = createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError);\r\nfunction createSearchAccessError(route, expression) {\r\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\r\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E249\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\r\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\r\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\r\n        value: \"E2\",\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n}\r\nfunction describeListOfPropertyNames(properties) {\r\n    switch(properties.length){\r\n        case 0:\r\n            throw Object.defineProperty(new InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.'), \"__NEXT_ERROR_CODE\", {\r\n                value: \"E531\",\r\n                enumerable: false,\r\n                configurable: true\r\n            });\r\n        case 1:\r\n            return `\\`${properties[0]}\\``;\r\n        case 2:\r\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\r\n        default:\r\n            {\r\n                let description = '';\r\n                for(let i = 0; i < properties.length - 1; i++){\r\n                    description += `\\`${properties[i]}\\`, `;\r\n                }\r\n                description += `, and \\`${properties[properties.length - 1]}\\``;\r\n                return description;\r\n            }\r\n    }\r\n}\r\n\r\n//# sourceMappingURL=search-params.js.map","import {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport type { FallbackRouteParams } from './fallback-params'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStorePPR,\n  type PrerenderStoreLegacy,\n  type StaticPrerenderStoreModern,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  describeStringPropertyAccess,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n\nexport type ParamValue = string | Array<string> | undefined\nexport type Params = Record<string, ParamValue>\n\n/**\n * In this version of Next.js the `params` prop passed to Layouts, Pages, and other Segments is a Promise.\n * However to facilitate migration to this new Promise type you can currently still access params directly on the Promise instance passed to these Segments.\n * The `UnsafeUnwrappedParams` type is available if you need to temporarily access the underlying params without first awaiting or `use`ing the Promise.\n *\n * In a future version of Next.js the `params` prop will be a plain Promise and this type will be removed.\n *\n * Typically instances of `params` can be updated automatically to be treated as a Promise by a codemod published alongside this Next.js version however if you\n * have not yet run the codemod of the codemod cannot detect certain instances of `params` usage you should first try to refactor your code to await `params`.\n *\n * If refactoring is not possible but you still want to be able to access params directly without typescript errors you can cast the params Promise to this type\n *\n * ```tsx\n * type Props = { params: Promise<{ id: string }>}\n *\n * export default async function Layout(props: Props) {\n *  const directParams = (props.params as unknown as UnsafeUnwrappedParams<typeof props.params>)\n *  return ...\n * }\n * ```\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedParams<P> =\n  P extends Promise<infer U> ? Omit<U, 'then' | 'status' | 'value'> : never\n\nexport function createParamsFromClient(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport type CreateServerParamsForMetadata = typeof createServerParamsForMetadata\nexport const createServerParamsForMetadata = createServerParamsForServerSegment\n\n// routes always runs in RSC context so it is equivalent to a Server Page Component\nexport function createServerParamsForRoute(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForRoute should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createServerParamsForServerSegment(\n  underlyingParams: Params,\n  workStore: WorkStore\n): Promise<Params> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderParams(\n          underlyingParams,\n          workStore,\n          workUnitStore\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerParamsForServerSegment should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderParams(underlyingParams, workUnitStore)\n      case 'request':\n        if (process.env.NODE_ENV === 'development') {\n          // Semantically we only need the dev tracking when running in `next dev`\n          // but since you would never use next dev with production NODE_ENV we use this\n          // as a proxy so we can statically exclude this code from production builds.\n          const devFallbackParams = workUnitStore.devFallbackParams\n          return createRenderParamsInDev(\n            underlyingParams,\n            devFallbackParams,\n            workStore\n          )\n        } else {\n          return createRenderParamsInProd(underlyingParams)\n        }\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderParamsForClientSegment(\n  underlyingParams: Params\n): Promise<Params> {\n  const workStore = workAsyncStorage.getStore()\n  if (!workStore) {\n    throw new InvariantError(\n      'Missing workStore in createPrerenderParamsForClientSegment'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams) {\n          for (let key in underlyingParams) {\n            if (fallbackParams.has(key)) {\n              // This params object has one or more fallback params, so we need\n              // to consider the awaiting of this params object \"dynamic\". Since\n              // we are in cacheComponents mode we encode this as a promise that never\n              // resolves.\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                '`params`'\n              )\n            }\n          }\n        }\n        break\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderParamsForClientSegment should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'prerender-runtime':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams)\n}\n\nfunction createStaticPrerenderParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<Params> {\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            // This params object has one or more fallback params, so we need\n            // to consider the awaiting of this params object \"dynamic\". Since\n            // we are in cacheComponents mode we encode this as a promise that never\n            // resolves.\n            return makeHangingParams(\n              underlyingParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-ppr': {\n      const fallbackParams = prerenderStore.fallbackRouteParams\n      if (fallbackParams) {\n        for (const key in underlyingParams) {\n          if (fallbackParams.has(key)) {\n            return makeErroringExoticParams(\n              underlyingParams,\n              fallbackParams,\n              workStore,\n              prerenderStore\n            )\n          }\n        }\n      }\n      break\n    }\n    case 'prerender-legacy':\n      break\n    default:\n      prerenderStore satisfies never\n  }\n\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedParams(underlyingParams)\n  } else {\n    return makeUntrackedExoticParams(underlyingParams)\n  }\n}\n\nfunction createRuntimePrerenderParams(\n  underlyingParams: Params,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<Params> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    process.env.__NEXT_CACHE_COMPONENTS\n      ? makeUntrackedParams(underlyingParams)\n      : makeUntrackedExoticParams(underlyingParams)\n  )\n}\n\nfunction createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedParams(underlyingParams)\n  }\n\n  return makeUntrackedExoticParams(underlyingParams)\n}\n\nfunction createRenderParamsInDev(\n  underlyingParams: Params,\n  devFallbackParams: FallbackRouteParams | null | undefined,\n  workStore: WorkStore\n): Promise<Params> {\n  let hasFallbackParams = false\n  if (devFallbackParams) {\n    for (let key in underlyingParams) {\n      if (devFallbackParams.has(key)) {\n        hasFallbackParams = true\n        break\n      }\n    }\n  }\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeDynamicallyTrackedParamsWithDevWarnings(\n      underlyingParams,\n      hasFallbackParams,\n      workStore\n    )\n  }\n\n  return makeDynamicallyTrackedExoticParamsWithDevWarnings(\n    underlyingParams,\n    hasFallbackParams,\n    workStore\n  )\n}\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nconst fallbackParamsProxyHandler: ProxyHandler<Promise<Params>> = {\n  get: function get(target, prop, receiver) {\n    if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n      const originalMethod = ReflectAdapter.get(target, prop, receiver)\n\n      return {\n        [prop]: (...args: unknown[]) => {\n          const store = dynamicAccessAsyncStorage.getStore()\n\n          if (store) {\n            store.abortController.abort(\n              new Error(`Accessed fallback \\`params\\` during prerendering.`)\n            )\n          }\n\n          return new Proxy(\n            originalMethod.apply(target, args),\n            fallbackParamsProxyHandler\n          )\n        },\n      }[prop]\n    }\n\n    return ReflectAdapter.get(target, prop, receiver)\n  },\n}\n\nfunction makeHangingParams(\n  underlyingParams: Params,\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStoreModern\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = new Proxy(\n    makeHangingPromise<Params>(\n      prerenderStore.renderSignal,\n      workStore.route,\n      '`params`'\n    ),\n    fallbackParamsProxyHandler\n  )\n\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeErroringExoticParams(\n  underlyingParams: Params,\n  fallbackParams: FallbackRouteParams,\n  workStore: WorkStore,\n  prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const augmentedUnderlying = { ...underlyingParams }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          enumerable: true,\n        })\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = describeStringPropertyAccess('params', prop)\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when cacheComponents is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no cacheComponents)\n              postponeWithTracking(\n                workStore.route,\n                expression,\n                prerenderStore.dynamicTracking\n              )\n            } else {\n              // Legacy Prerender\n              throwToInterruptStaticGeneration(\n                expression,\n                workStore,\n                prerenderStore\n              )\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true,\n            })\n          },\n          enumerable: true,\n          configurable: true,\n        })\n      } else {\n        ;(promise as any)[prop] = underlyingParams[prop]\n      }\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(underlyingParams)\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          syncIODev(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      syncIODev(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\n// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just\n// logging the sync access without actually defining the params on the promise.\nfunction makeDynamicallyTrackedParamsWithDevWarnings(\n  underlyingParams: Params,\n  hasFallbackParams: boolean,\n  store: WorkStore\n): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = hasFallbackParams\n    ? makeDevtoolsIOAwarePromise(underlyingParams)\n    : // We don't want to force an environment transition when this params is not part of the fallback params set\n      Promise.resolve(underlyingParams)\n\n  const proxiedProperties = new Set<string>()\n  const unproxiedProperties: Array<string> = []\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop)\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n          // We are accessing a property that was proxied to the promise instance\n          proxiedProperties.has(prop)\n        ) {\n          const expression = describeStringPropertyAccess('params', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return ReflectAdapter.set(target, prop, value, receiver)\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression'\n      warnForIncompleteEnumeration(store.route, expression, unproxiedProperties)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedParams.set(underlyingParams, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction syncIODev(\n  route: string | undefined,\n  expression: string,\n  missingProperties?: Array<string>\n) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        if (workUnitStore.prerenderPhase === true) {\n          // When we're rendering dynamically in dev, we need to advance out of\n          // the Prerender environment when we read Request data synchronously.\n          trackSynchronousRequestDataAccessInDev(workUnitStore)\n        }\n        break\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties)\n  } else {\n    warnForSyncAccess(route, expression)\n  }\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createParamsAccessError\n)\n\nconst warnForIncompleteEnumeration =\n  createDedupedByCallsiteServerErrorLoggerDev(createIncompleteEnumerationError)\n\nfunction createParamsAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction createIncompleteEnumerationError(\n  route: string | undefined,\n  expression: string,\n  missingProperties: Array<string>\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`params\\` should be awaited before using its properties. ` +\n      `The following properties were not available through enumeration ` +\n      `because they conflict with builtin property names: ` +\n      `${describeListOfPropertyNames(missingProperties)}. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction describeListOfPropertyNames(properties: Array<string>) {\n  switch (properties.length) {\n    case 0:\n      throw new InvariantError(\n        'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'\n      )\n    case 1:\n      return `\\`${properties[0]}\\``\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``\n    default: {\n      let description = ''\n      for (let i = 0; i < properties.length - 1; i++) {\n        description += `\\`${properties[i]}\\`, `\n      }\n      description += `, and \\`${properties[properties.length - 1]}\\``\n      return description\n    }\n  }\n}\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","'use client'\n\n// This is a client component that only renders during SSR,\n// but will be replaced during streaming with an icon insertion script tag.\n// We don't want it to be presented anywhere so it's only visible during streaming,\n// right after the icon meta tags so that browser can pick it up as soon as it's rendered.\n// Note: we don't just emit the script here because we only need the script if it's not in the head,\n// and we need it to be hoistable alongside the other metadata but sync scripts are not hoistable.\nexport const IconMark = () => {\n  if (typeof window !== 'undefined') {\n    return null\n  }\n  return <meta name=\"nxt-icon\" />\n}\n","'use client'\n\nimport { Suspense, use } from 'react'\nimport type { StreamingMetadataResolvedState } from './types'\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layer\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n","'use client'\n\nimport type { ReactNode } from 'react'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from './boundary-constants'\n\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n  [METADATA_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [VIEWPORT_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [OUTLET_BOUNDARY_NAME]: function ({ children }: { children: ReactNode }) {\n    return children\n  },\n  [ROOT_LAYOUT_BOUNDARY_NAME]: function ({\n    children,\n  }: {\n    children: ReactNode\n  }) {\n    return children\n  },\n}\n\nexport const MetadataBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[METADATA_BOUNDARY_NAME.slice(0) as typeof METADATA_BOUNDARY_NAME]\n\nexport const ViewportBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[VIEWPORT_BOUNDARY_NAME.slice(0) as typeof VIEWPORT_BOUNDARY_NAME]\n\nexport const OutletBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[OUTLET_BOUNDARY_NAME.slice(0) as typeof OUTLET_BOUNDARY_NAME]\n\nexport const RootLayoutBoundary =\n  // We use slice(0) to trick the bundler into not inlining/minifying the function\n  // so it retains the name inferred from the namespace object\n  NameSpace[\n    ROOT_LAYOUT_BOUNDARY_NAME.slice(0) as typeof ROOT_LAYOUT_BOUNDARY_NAME\n  ]\n"],"names":["HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","Object","values","HTTP_ERROR_FALLBACK_ERROR_CODE","isHTTPAccessFallbackError","error","digest","prefix","httpStatus","split","has","Number","getAccessFallbackHTTPStatus","getAccessFallbackErrorTypeByStatus","status","BAILOUT_TO_CSR","BailoutToCSRError","Error","constructor","reason","isBailoutToCSRError","err","METADATA_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","InvariantError","message","options","endsWith","name","workAsyncStorage","workUnitAsyncStorage","bailoutToClientRendering","workStore","getStore","forceStatic","workUnitStore","type","React","useContext","TemplateContext","RenderFromTemplateContext","children","ReflectAdapter","throwToInterruptStaticGeneration","postponeWithTracking","trackSynchronousRequestDataAccessInDev","delayUntilRuntimeStage","throwInvariantForMissingStore","describeStringPropertyAccess","wellKnownProperties","makeDevtoolsIOAwarePromise","makeHangingPromise","createDedupedByCallsiteServerErrorLoggerDev","dynamicAccessAsyncStorage","createParamsFromClient","underlyingParams","createStaticPrerenderParams","process","env","NODE_ENV","devFallbackParams","createRenderParamsInDev","createRenderParamsInProd","createServerParamsForMetadata","createServerParamsForServerSegment","createServerParamsForRoute","createRuntimePrerenderParams","createPrerenderParamsForClientSegment","fallbackParams","fallbackRouteParams","key","renderSignal","route","Promise","resolve","prerenderStore","makeHangingParams","makeErroringExoticParams","__NEXT_CACHE_COMPONENTS","makeUntrackedParams","makeUntrackedExoticParams","hasFallbackParams","makeDynamicallyTrackedParamsWithDevWarnings","makeDynamicallyTrackedExoticParamsWithDevWarnings","CachedParams","WeakMap","fallbackParamsProxyHandler","get","target","prop","receiver","originalMethod","args","store","abortController","abort","Proxy","apply","cachedParams","promise","set","augmentedUnderlying","keys","forEach","defineProperty","expression","dynamicTracking","enumerable","newValue","value","writable","configurable","proxiedProperties","unproxiedProperties","push","add","proxiedPromise","syncIODev","delete","ownKeys","Reflect","warnForSyncAccess","warnForIncompleteEnumeration","missingProperties","prerenderPhase","length","createParamsAccessError","createIncompleteEnumerationError","describeListOfPropertyNames","properties","description","i","ClientPageRoot","Component","searchParams","params","promises","window","require","clientSearchParams","clientParams","createSearchParamsFromClient","createRenderSearchParamsFromClient","createRenderParamsFromClient","ClientSegmentRoot","slots","IconMark","meta","Suspense","use","MetadataOutlet","AsyncMetadataOutlet","fallback","NameSpace","MetadataBoundary","slice","ViewportBoundary","OutletBoundary","RootLayoutBoundary"],"mappings":"oOAAO,IAAMA,EAAwB,CACnCC,UAAW,IACXC,UAAW,IACXC,aAAc,GAChB,EAAC,AAEKC,EAAgB,IAAIC,IAAIC,OAAOC,MAAM,CAACP,IAE/BQ,EAAiC,2BAA0B,AAajE,SAASC,EACdC,CAAc,EAEd,GACmB,UAAjB,OAAOA,GACG,OAAVA,GACA,CAAE,CAAA,WAAYA,CAAAA,CAAI,EACM,UAAxB,AACA,OADOA,EAAMC,MAAM,CAEnB,OAAO,EAET,GAAM,CAACC,EAAQC,EAAW,CAAGH,EAAMC,MAAM,CAACG,KAAK,CAAC,KAEhD,OACEF,IAAWJ,GACXJ,EAAcW,GAAG,CAACC,OAAOH,GAE7B,CAEO,SAASI,EACdP,CAA8B,EAG9B,OAAOM,OAAOH,AADKH,EAAMC,MAAM,CAACG,KAAK,CAAC,IAAI,CAAC,EAAE,CAE/C,CAEO,SAASI,EACdC,CAAc,EAEd,OAAQA,GACN,KAAK,IACH,MAAO,cACT,MAAK,IACH,MAAO,WACT,MAAK,IACH,MAAO,WACT,SACE,MACJ,CACF,4EC5DA,IAAA,EAAA,EAAA,CAAA,CAAA,oICAO,IAAI,EAAmC,SAAS,CAAkB,EAIrE,OAJ4B,AAC5B,CAAkB,CAAC,EAAmB,OADC,CACU,CAAG,IAAI,CAAG,EAAtB,SACrC,CAAkB,CAAC,EAAmB,gBAAD,CAAqB,CAAG,IAAI,CAAG,oBACpE,CAAkB,CAAC,EAAmB,gBAAD,CAAqB,CAAG,IAAI,CAAG,oBAC7D,CACX,EAAE,CAAC,GCJI,CDMP,GCNa,EAAsB,gBAC5B,IAAI,EAA6B,SAAS,CAAY,EAGzD,CAHsB,MACtB,EDI4C,ACJ/B,GADoB,CACb,CAAG,KAAX,EACZ,EAAa,OAAU,CAAG,EAAd,QACL,CACX,EAAE,CAAC,GAOQ,SAAS,EAAgB,CAAK,EACrC,GAAI,AAAiB,iBAAV,GAAgC,OAAV,GAAkB,CAAC,CAAC,WAAY,CAAA,CAAK,EAA6B,UAAxB,AAAkC,OAA3B,EAAM,MAAM,CAC1F,OAAO,EAEX,IAAM,EAAS,EAAM,MAAM,CAAC,KAAK,CAAC,KAC5B,CAAC,EAAW,EAAK,CAAG,EACpB,EAAc,EAAO,KAAK,CAAC,EAAG,CAAC,GAAG,IAAI,CAAC,KAEvC,EAAa,OADJ,AACW,EADJ,EAAE,CAAC,CAAC,IAE1B,OAAO,IAAc,GAAwB,CAAS,eAAsB,IAAhC,KAAuB,CAAS,CAAM,EAA4B,UAAvB,OAAO,GAA4B,CAAC,MAAM,IAAe,KAAc,CAClK,CFjBW,CEmBX,QFnBoB,EAAkB,CAAK,EACvC,OAAO,EAAgB,IAAU,CAAA,EAAA,EAAA,WEkBK,cFlBL,AAAyB,EAAC,EAC/D,EAEA,gDAAgD,qCGThD,IAAMC,EAAiB,kCAGhB,OAAMC,UAA0BC,MAGrCC,YAA4BC,CAAc,CAAE,CAC1C,KAAK,CAAE,sCAAqCA,GAAAA,IAAAA,CADlBA,MAAAA,CAAAA,EAAAA,IAAAA,CAFZb,MAAAA,CAASS,CAIzB,CACF,CAGO,SAASK,EAAoBC,CAAY,QAC9C,AAAmB,UAAf,OAAOA,GAA4B,OAARA,CAAgB,CAAE,CAAA,WAAYA,GAAE,AAIxDA,EAAIf,CAJwD,KAIlD,GAAKS,CACxB,8JCnBO,IAAMO,EAAyB,6BAA4B,AACrDC,EAAyB,6BAA4B,AACrDC,EAAuB,2BAA0B,AACjDC,EAA4B,gCAA+B,qDCHjE,OAAMC,UAAuBT,MAClCC,YAAYS,CAAe,CAAEC,CAAsB,CAAE,CACnD,KAAK,CACF,eAAaD,CAAAA,CAAQE,QAAQ,CAAC,KAAOF,EAAUA,EAAU,GAAA,CAAE,CAAE,6BAC9DC,GAEF,IAAI,CAACE,IAAI,CAAG,gBACd,CACF,4CIRO,SAAS,EAA+B,CAAG,QAC9C,AAAmB,UAAf,OAAO,GAAoB,AAAQ,QAAQ,CAAC,CAAC,WAAY,GAAG,AAGzD,EAAI,CAHwD,KAGlD,GAAK,CAC1B,mHACA,IAAM,EAA4B,2BAClC,OAAM,UAAqC,MACvC,YAAY,CAAK,CAAE,CAAU,CAAC,CAC1B,KAAK,CAAC,CAAC,qBAAqB,EAAE,EAAW,qGAAqG,EAAE,EAAW,8KAA8K,EAAE,EAAM,EAAE,CAAC,EAAG,IAAI,CAAC,KAAK,CAAG,EAAO,IAAI,CAAC,UAAU,CAAG,EAAY,IAAI,CAAC,MAAM,CAAG,CAC3Z,CACJ,CACA,IAAM,EAAyB,IAAI,QAOxB,SAAS,EAAmB,CAAM,CAAE,CAAK,CAAE,CAAU,EAC5D,GAAI,EAAO,OAAO,CACd,CADgB,MACT,QAAQ,MAAM,CAAC,IAAI,EAA6B,EAAO,GAC3D,EACH,IAAM,EAAiB,IAAI,QAAQ,CAAC,EAAG,KACnC,IAAM,EAAiB,EAAO,IAAI,CAAC,KAAM,IAAI,EAA6B,EAAO,IAC7E,EAAmB,EAAuB,GAAG,CAAC,GAClD,GAAI,EACA,EAAiB,IAAI,CAAC,OACnB,CACH,CAHkB,GAGZ,EAAY,CACd,EACH,CACD,EAAuB,GAAG,CAAC,EAAQ,GACnC,EAAO,gBAAgB,CAAC,QAAS,KAC7B,IAAI,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,IACjC,AADqC,CAC5B,CAAC,EAAE,EAEpB,EAAG,CACC,MAAM,CACV,EACJ,CACJ,GAKA,OADA,EAAe,KAAK,CAAC,GACd,CACX,CACJ,CACA,SAAS,IAAgB,CAClB,SAAS,EAA2B,CAAU,EAGjD,OAAO,IAAI,QAAQ,AAAC,IAEhB,WAAW,KACP,EAAQ,EACZ,EAAG,EACP,EACJ,EAEA,mDAAmD,03BHxCnD,IAAA,EAAA,EAAA,CAAA,CAAA,4ECrBA,IAAM,EAAqB,sBACpB,OAAM,UAA2B,MACpC,YAAY,CAAW,CAAC,CACpB,KAAK,CAAC,yBAA2B,GAAc,IAAI,CAAC,WAAW,CAAG,EAAa,IAAI,CAAC,MAAM,CAAG,CACjG,CACJ,CACO,SAAS,EAAqB,CAAG,QACpC,AAAmB,UAAf,OAAO,GAA4B,OAAR,CAAgB,CAAC,CAAC,WAAY,GAA8B,AAA3B,UAAqC,AAAhC,OAAO,EAAI,MAAM,EAG/E,EAAI,MAAM,GAAK,CAC1B,EAEA,yCCZO,ODYyC,ACZnC,UAA8B,MACvC,YAAY,GAAG,CAAI,CAAC,CAChB,KAAK,IAAI,GAAO,IAAI,CAAC,IAAI,CAHD,EAGI,uBAChC,CACJ,CFmBA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAEA,EAAA,EAAA,CAAA,CAAA,OItBW,IAAM,EAAqB,AAAC,IAOnC,QAAQ,OAAO,GAAG,IAAI,CAAC,KAIf,QAAQ,QAAQ,CAAC,EAEzB,EACJ,EJUA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAiD,YAAnC,OAAO,EAAA,OAAK,CAAC,iBAAiB,CAC3C,SAAS,EAA2B,CAAsB,EAC7D,MAAO,wBACH,EACA,gBAAiB,EAAE,CACnB,0BAA2B,IAC/B,CACJ,CACO,SAAS,IACZ,MAAO,CACH,sBAAsB,EACtB,mBAAoB,GACpB,oBAAoB,EACpB,mBAAmB,EACnB,cAAe,EAAE,AACrB,CACJ,CACO,SAAS,EAAsB,CAAa,EAC/C,IAAI,EACJ,OAA+E,AAAxE,OAAC,EAAkC,EAAc,eAAe,CAAC,EAAA,AAAE,EAAY,KAAK,EAAI,EAAgC,UAAU,AAC7I,CAOW,SAAS,EAA0B,CAAK,CAAE,CAAa,CAAE,CAAU,EAC1E,GAAI,EACA,OAAO,EAAc,IADN,AACU,EACrB,IAAK,QACL,IAAK,iBAML,IAAK,gBADD,MAUR,CAKJ,IAAI,EAAM,YAAY,GAAI,EAAM,WAAW,EAAE,AAC7C,GAAI,EAAM,kBAAkB,CACxB,CAD0B,KACpB,OAAO,cAAc,CAAC,IAAI,EAAsB,CAAC,MAAM,EAAE,EAAM,KAAK,CAAC,8EAA8E,EAAE,EAAW,4HAA4H,CAAC,EAAG,oBAAqB,CACvT,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,GAAI,EACA,OAAO,EAAc,IADN,AACU,EACrB,IAAK,gBACD,OAAO,EAAqB,EAAM,KAAK,CAAE,EAAY,EAAc,eAAe,CACtF,KAAK,mBACD,EAAc,UAAU,CAAG,EAG3B,IAAM,EAAM,OAAO,cAAc,CAAC,IAAI,EAAmB,CAAC,MAAM,EAAE,EAAM,KAAK,CAAC,iDAAiD,EAAE,EAAW,2EAA2E,CAAC,EAAG,oBAAqB,CAC5O,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAGA,OAFA,EAAM,uBAAuB,CAAG,EAChC,EAAM,iBAAiB,CAAG,EAAI,KAAK,CAC7B,CAQd,EAER,CAMW,SAAS,EAAiC,CAAU,CAAE,CAAK,CAAE,CAAc,EAElF,IAAM,EAAM,OAAO,cAAc,CAAC,IAAI,EAAmB,CAAC,MAAM,EAAE,EAAM,KAAK,CAAC,mDAAmD,EAAE,EAAW,6EAA6E,CAAC,EAAG,oBAAqB,CAChP,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAIA,OAHA,EAAe,UAAU,CAAG,EAC5B,EAAM,uBAAuB,CAAG,EAChC,EAAM,iBAAiB,CAAG,EAAI,KAAK,CAC7B,CACV,CAOW,SAAS,EAAgC,CAAa,EAC7D,OAAO,EAAc,IAAI,EACrB,IAAK,QACL,IAAK,iBAML,IAAK,gBADD,MAiBR,CACJ,CACA,SAAS,EAAoC,CAAK,CAAE,CAAU,CAAE,CAAc,EAE1E,IAAM,EAAQ,EADC,CAAC,MAAM,EAAE,EAAM,mBACgB,8CADiD,EAAE,EAAW,CAAC,CAAC,EAE9G,EAAe,UAAU,CAAC,KAAK,CAAC,GAChC,IAAM,EAAkB,EAAe,eAAe,CAClD,GACA,EAAgB,YADC,GACc,CAAC,IAAI,CAAC,CAGjC,MAAO,EAAgB,sBAAsB,CAAG,AAAI,QAAQ,KAAK,MAAG,EACpE,YACJ,EAER,CACO,SAAS,EAAmC,CAAK,CAAE,CAAU,CAAE,CAAc,CAAE,CAAc,EAChG,IAAM,EAAkB,EAAe,eAAe,CACtD,EAAoC,EAAO,EAAY,GAKnD,GACkD,MAAM,CAApD,EAAgB,KADH,oBAC4B,GACzC,EAAgB,yBAAyB,CAAG,CAAA,CAGxD,CACO,SAAS,EAAsC,CAAY,EAG9D,EAAa,cAAc,EAAG,CAClC,CAUW,SAAS,EAA4C,CAAK,CAAE,CAAU,CAAE,CAAc,CAAE,CAAc,EAE7G,GAAgC,AAA5B,KADoB,EAAe,UAAU,CAAC,MAAM,CACpC,OAAO,CAAY,CAMnC,EAAoC,EAAO,EAAY,GAKvD,IAAM,EAAkB,EAAe,eAAe,CAClD,GACkD,MAAM,CAApD,EAAgB,KADH,oBAC4B,GACzC,EAAgB,yBAAyB,CAAG,CAAA,CAGxD,CACA,MAAM,EAAgC,CAAC,MAAM,EAAE,EAAM,iEAAiE,EAAE,EAAW,CAAC,CAAC,CACzI,CAOW,SAAS,EAAuB,CAAe,EAClD,EAAgB,yBAAyB,EAAE,AAG3C,QAAQ,KAAK,CAAC,EAAgB,yBAAyB,CAE/D,CAEO,IAAM,EAAyC,EAC/C,SAAS,EAAS,QAAE,CAAM,OAAE,CAAK,CAAE,EACtC,IAAM,EAAiB,EAAA,oBAAoB,CAAC,QAAQ,GAEpD,EAAqB,EAAO,EADJ,GAA0C,GAC9B,eADM,EAAe,IAAI,CAAuB,EAAe,eAAe,CAAG,KAEzH,CACO,SAAS,EAAqB,CAAK,CAAE,CAAU,CAAE,CAAe,EA6EvE,AA5EI,SA4EK,GACL,GAAI,CAAC,EACD,MAAM,KADQ,EACD,cAAc,CAAC,AAAI,MAAM,CAAC,gIAAgI,CAAC,EAAG,oBAAqB,CAC5L,MAAO,OACP,WAAY,GACZ,cAAc,CAClB,GAER,IAnFQ,GACA,EAAgB,YADC,GACc,CAAC,IAAI,CAAC,CAGjC,MAAO,EAAgB,sBAAsB,CAAG,AAAI,QAAQ,KAAK,MAAG,aACpE,CACJ,GAEJ,EAAA,OAAK,CAAC,iBAAiB,CAAC,EAAqB,EAAO,GACxD,CACA,SAAS,EAAqB,CAAK,CAAE,CAAU,EAC3C,MAAO,CAAC,MAAM,EAAE,EAAM,iEAAiE,EAAE,EAAW,kKAAE,CAAC,AAC3G,CACO,EAFuG,CAAC,MAE/F,EAAkB,CAAG,QACjC,AAAmB,UAAf,OAAO,GAA4B,OAAR,GAAuC,UAAU,AAAjC,OAAO,EAAI,OAAO,EACtD,EAAwB,EAAI,AAJmJ,CAAC,GAAG,CAAC,EAIjJ,CAGlD,CACA,SAAS,EAAwB,CAAM,EACnC,OAAO,EAAO,QAAQ,CAAC,6CATyP,CAAC,sBASpL,EAAO,QAAQ,CAAC,gEACjH,CACA,IAAoE,IAAhE,EAAwB,CAA+C,CAA1B,MAAO,QACpD,MAAM,OAAO,cAAc,CAAK,AAAJ,MAAU,0FAA2F,oBAAqB,CAClJ,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,IAAM,EAA6B,6BACnC,SAAS,EAAgC,CAAO,EAC5C,IAAM,EAAQ,OAAO,cAAc,CAAK,AAAJ,MAAU,GAAU,oBAAqB,CACzE,MAAO,OACP,WAAY,GACZ,cAAc,CAClB,GAEA,OADA,EAAM,MAAM,CAAG,EACR,CACX,CACO,SAAS,EAA4B,CAAK,EAC7C,MAAwB,UAAjB,OAAO,GAAgC,OAAV,GAAkB,EAAM,MAAM,GAAK,GAA8B,SAAU,GAAS,YAAa,GAAS,aAAiB,KACnK,CACO,SAAS,EAAoB,CAAe,EAC/C,OAAO,EAAgB,MAAM,CAAG,CACpC,CACO,SAAS,EAAqB,CAAa,CAAE,CAAa,EAK7D,OADA,EAAc,eAAe,CAAC,IAAI,IAAI,EAAc,eAAe,EAC5D,EAAc,eAAe,AACxC,CACO,SAAS,EAAyB,CAAe,EACpD,OAAO,EAAgB,MAAM,CAAC,AAAC,GAAiC,UAAxB,OAAO,EAAO,KAAK,EAAiB,EAAO,KAAK,CAAC,MAAM,CAAG,GAAG,GAAG,CAAC,CAAC,YAAE,CAAU,OAAE,CAAK,CAAE,IAC3H,EAAQ,EAAM,KAAK,CAAC,MAAK,AAGxB,KAAK,CAAC,GAAG,MAAM,CAAC,AAAC,KAEV,EAAK,QAAQ,CAAC,uBAAuB,AAIrC,EAAK,QAAQ,CAAC,MAT2E,aASxD,AAIjC,EAAK,QAAQ,CAAC,YAAY,CAI/B,IAAI,CAAC,MACD,CAAC,0BAA0B,EAAE,EAAW;AAAG,EAAE,EAAA,CAAO,EAEnE,CAaW,SAAS,IAChB,IAAM,EAAa,IAAI,gBAMvB,OALA,EAAW,KAAK,CAAC,OAAO,cAAc,CAAC,IAAI,EAAA,iBAAiB,CAAC,qBAAsB,oBAAqB,CACpG,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,IACO,EAAW,MAAM,AAC5B,CAKW,SAAS,EAA8B,CAAa,EAC3D,OAAO,EAAc,IAAI,EACrB,IAAK,YACL,IAAK,oBACD,IAAM,EAAa,IAAI,gBACvB,GAAI,EAAc,WAAW,CAIzB,CAJ2B,CAIb,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC,KACxC,EAAW,KAAK,EACpB,OACG,CAaH,IAAM,EAAsB,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,GAC/C,EACA,EAAoB,IAAI,CAAC,IAAI,EAAmB,IAAI,EAD/B,AAC0C,KAAK,KAEpE,EAAmB,IAAI,EAAW,KAAK,GAE/C,CACA,OAAO,EAAW,MAAM,AAC5B,KAAK,mBACL,IAAK,gBACL,IAAK,mBACL,IAAK,UACL,IAAK,QACL,IAAK,gBACL,IAAK,iBACD,MAGR,CACJ,AAJmB,CAKZ,SAAS,EAAsB,CAAU,CAAE,CAAc,EAC5D,IAAM,EAAkB,EAAe,eAAe,CAClD,GACA,EAAgB,YADC,GACc,CAAC,IAAI,CAAC,CACjC,MAAO,EAAgB,sBAAsB,CAAO,AAAJ,QAAY,KAAK,MAAG,aACpE,CACJ,EAER,CACO,SAAS,EAAsB,CAAU,EAC5C,IAAM,EAAY,EAAA,gBAAgB,CAAC,QAAQ,GACrC,EAAgB,EAAA,oBAAoB,CAAC,QAAQ,GACnD,GAAI,GAAa,EACb,OAAO,EAAc,IADO,AACH,EACrB,IAAK,mBACL,IAAK,YACD,CACI,IAAM,EAAiB,EAAc,mBAAmB,CACpD,GAAkB,EAAe,IAAI,CAAG,GAIxC,AAJ2C,EAI3C,OAAK,CAAC,GAAG,CAAC,EAAmB,EAAc,YAAY,CAAE,EAAU,KAAK,CAAE,IAE9E,KACJ,CACJ,IAAK,gBACD,CACI,IAAM,EAAiB,EAAc,mBAAmB,CACxD,GAAI,GAAkB,EAAe,IAAI,CAAG,EACxC,CAD2C,MACpC,EAAqB,EAAU,KAAK,CAAE,EAAY,EAAc,eAAe,EAE1F,KACJ,CACJ,IAAK,oBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,CAAC,EAAE,EAAE,EAAW,uEAAuE,EAAE,EAAW,+EAA+E,CAAC,EAAG,oBAAqB,CACvP,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,KAAK,QACL,IAAK,gBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,CAAC,EAAE,EAAE,EAAW,iEAAiE,EAAE,EAAW,+EAA+E,CAAC,EAAG,oBAAqB,CACjP,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAOR,CAER,CACA,IAAM,EAAmB,mCAenB,EAA4D,AAAI,OAAO,CAAC,uDAAuD,EAAE,oBAAoB,yCAAyC,+DAAE,EAAA,yBAAyB,CAAC,cAAc,CAAC,EACzO,EAAmB,AAAI,OAAO,CAAC,UAAU,EAAE,EAAA,sBAAsB,CAAC,QAAQ,CAAC,EAC3E,EAAmB,AAAI,OAAO,CAAC,UAAU,EAAE,EAAA,sBAAsB,CAAC,QAAQ,CAAC,EAC3E,EAAiB,AAAI,OAAO,CAAC,UAAU,EAAE,EAAA,oBAAoB,CAAC,QAAQ,CAAC,EACtE,SAAS,EAA0B,CAAS,CAAE,CAAc,CAAE,CAAiB,CAAE,CAAa,EACjG,IAAI,EAAe,IAAI,CAAC,IAGjB,GAAI,EAAiB,IAAI,CAAC,GAAiB,AAHT,CAIrC,EAAkB,kBAAkB,EAAG,EACvC,MACJ,CAAO,GAAI,EAAiB,IAAI,CAAC,GAAiB,CAC9C,EAAkB,kBAAkB,EAAG,EACvC,MACJ,CAAO,GAAI,EAA0D,IAAI,CAAC,GAAiB,CAIvF,EAAkB,iBAAiB,EAAG,EACtC,EAAkB,oBAAoB,EAAG,EACzC,MACJ,MAAO,GAAI,EAAiB,IAAI,CAAC,GAAiB,CAG9C,EAAkB,iBAAiB,EAAG,EACtC,MACJ,KAIO,CAJA,GAAI,EAAc,yBAAyB,CAAE,YAEhD,EAAkB,aAAa,CAAC,IAAI,CAAC,EAAc,yBAAyB,EAI5E,IAAM,EAAQ,AAQlB,SAAS,AAAqC,CAAO,CAAE,CAAc,EAErE,IAAM,EAAQ,OAAO,UAVkC,IAUpB,CAAK,AAAJ,MAAU,GAAU,oBAAqB,CACzE,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEA,OADA,EAAM,KAAK,CAAG,EAAM,IAAI,CAAG,KAAO,EAAyB,EACpD,CACX,EAlBwB,CAAC,EAgBuB,CAAC,IAhBjB,CAgB6C,CAhB3C,EAAU,KAAK,CAAC,2NAA2N,CAAC,CAC1M,eAC5D,EAAkB,aAAa,CAAC,IAAI,CAAC,EAEzC,EACJ,CAcO,IAAI,EAA6B,SAAS,CAAY,EAIzD,CAJsB,MACtB,CAAY,CAAC,EAAa,CADO,GACA,CAAG,EAAE,CAAG,EAAhB,KACzB,CAAY,CAAC,EAAa,KAAQ,CAAG,EAAE,CAAG,CAAjB,OACzB,CAAY,CAAC,EAAa,OAAU,CAAG,EAAd,AAAgB,CAAG,UACrC,CACX,EAAE,CAAC,GACI,SAAS,GAA0B,CAAS,CAAE,CAAK,EACtD,QAAQ,KAAK,CAAC,GACT,EAAU,GAAG,EAAE,CACZ,EAAU,sBAAsB,CAChC,CADkC,OAC1B,KAAK,CAAC,CAAC,iIAAiI,EAAE,EAAU,KAAK,CAAC,2CAA2C,CAAC,EAE9M,QAAQ,KAAK,CAAC,CAAC;0EAC+C,EAAE,EAAU,KAAK,CAAC;qGACS,CAAC,EAGtG,CACO,SAAS,GAAyB,CAAS,CAAE,CAAO,CAAE,CAAiB,CAAE,CAAa,EACzF,GAAgB,IAAZ,EAAe,CACf,GAAI,EAAkB,oBAAoB,CAItC,CAJwC,MAM5C,GAAI,EAAc,yBAAyB,CAKvC,CALyC,KAIzC,GAA0B,EAAW,EAAc,yBAAyB,EACtE,IAAI,EAKd,IAAM,EAAgB,EAAkB,aAAa,CACrD,GAAI,EAAc,MAAM,CAAG,EAAG,CAC1B,IAAI,IAAI,EAAI,EAAG,EAAI,EAAc,MAAM,CAAE,IAAI,AACzC,GAA0B,EAAW,CAAa,CAAC,EAAE,CAEzD,OAAM,IAAI,CACd,CAKA,GAAI,EAAkB,kBAAkB,CAEpC,CAFsC,KACtC,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,EAAU,KAAK,CAAC,8QAA8Q,CAAC,EACjT,IAAI,EAEd,GAAgB,GAAG,CAAf,EAKA,MADA,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,EAAU,KAAK,CAAC,wGAAwG,CAAC,EAC3I,IAAI,CAElB,MACI,CADG,GACyC,IAAxC,EAAkB,iBAAiB,EAAc,EAAkB,kBAAkB,CAErF,CAFuF,KACvF,QAAQ,KAAK,CAAC,CAAC,OAAO,EAAE,EAAU,KAAK,CAAC,8PAA8P,CAAC,EACjS,IAAI,CAGtB,CACO,SAAS,GAAuB,CAAc,CAAE,CAAM,SACzD,AAAI,EAAe,mBAAmB,CAC3B,CAD6B,CACd,mBAAmB,CAAC,IAAI,CAAC,IAAI,GAEhD,CACX,EAEA,6CAA6C,OMvkBtC,SAAS,EAAiB,CAAK,EAClC,GAAI,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,IAAU,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,IAAU,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,IAAU,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,IDLvF,MCKiG,IDLlH,OAAO,GAAsB,AAAU,UAAQ,ACK8E,EDLxE,QAAQ,GAAK,GCKqE,CAAA,EAAA,EAAA,8BAAA,AAA8B,EAAC,GACzK,KADiL,CAC3K,EAEN,aAAiB,OAAS,UAAW,GACrC,EAAiB,EAD2B,AACrB,KAAK,CAEpC,EAEA,QAfA,IAAA,EAAA,EAAA,CAAA,CAAA,ODAA,IAAM,EAAsB,OAAO,GAAG,CAAC,SCeY,SAbnD,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,uECLA,IAAA,EAAkC,EAAA,CAAzBd,AAAyB,CAAA,OAClC,EAAiC,EAAA,CAAA,AAD+C,AACvEe,CAAwB,GADP,IAE1B,EAAqC,EAFH,AAEG,CAAA,AAA5BC,CAA4B,EADZ,GAA6D,EAG/E,GAH0B,MAGjBC,EAAyBd,CAAc,AAF1B,EAG3B,IAAMe,EAHuF,AAG3EH,AAHiB,EAGjBA,gBAAAA,CAAiBI,QAAQ,GAE3C,GAAID,QAAAA,KAAAA,EAAAA,EAAWE,WAAW,CAAE,OAE5B,IAAMC,EAAgBL,EAAAA,oBAAAA,CAAqBG,QAAQ,GAEnD,GAAIE,EACF,OAAQA,EAAcC,IADL,AACS,EACxB,IAAK,YACL,IAAK,oBACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,MAAM,OAAA,cAA6B,CAA7B,IAAItB,EAAAA,iBAAAA,CAAkBG,GAAtB,oBAAA,OAAA,mBAAA,gBAAA,CAA4B,EAQtC,CAEJ,+EG5BA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OA0CW,SAAS,UAKhB,CAAI,AAzCJ,SAAS,EAC0B,CAE/B,GAAM,WAsCoB,WAtClB,CAAoB,CAAE,CAAA,EAAA,CAAA,CAAA,OACxB,EAAgB,EAAqB,QAAQ,GACnD,GAAI,CAAC,EAAe,OAAO,EAC3B,OAAO,EAAc,IAAI,EACrB,IAAK,YACL,IAAK,mBACL,IAAK,gBACD,IAAM,EAAiB,EAAc,mBAAmB,CACxD,QAAO,GAAiB,EAAe,IAAI,CAAG,CAUtD,CACA,EAX0D,KAWnD,CACX,CAEJ,IAsBW,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,eAAe,EALtB,IAMf,EAEA,gDAAgD,YDxDhD,IAAA,EAAA,EAAA,CAAA,CAAA,WAYA,EAAA,EAAA,CAAA,CAAA,OAEA,EAAA,EAAA,CAAA,CAAA,KACA,OAAM,UAAwC,EAAA,OAAK,CAAC,SAAS,CACzD,mBAAoB,CAQpB,CACA,OAAO,yBAAyB,CAAK,CAAE,CACnC,GAAI,CAAA,EAAA,EAAA,yBAAyB,AAAzB,EAA0B,GAE1B,KAFkC,CAE3B,CACH,gBAFe,CAAA,AAEE,EAFF,EAAA,2BAAA,AAA2B,EAAC,EAG/C,CAGJ,OAAM,CACV,CACA,OAAO,yBAAyB,CAAK,CAAE,CAAK,CAAE,QAM1C,AAAI,EAAM,QAAQ,GAAK,EAAM,gBAAgB,EAAI,EAAM,eAAe,CAC3D,CAD6D,AAEhE,qBAAiB,EACjB,iBAAkB,EAAM,QAAQ,AACpC,EAEG,CACH,gBAAiB,EAAM,eAAe,CACtC,iBAAkB,EAAM,QAAQ,AACpC,CACJ,CACA,QAAS,CACL,GAAM,UAAE,CAAQ,WAAE,CAAS,cAAE,CAAY,UAAE,CAAQ,CAAE,CAAG,IAAI,CAAC,KAAK,CAC5D,iBAAE,CAAe,CAAE,CAAG,IAAI,CAAC,KAAK,CAChC,EAAkB,CACpB,CAAC,EAAA,qBAAqB,CAAC,SAAS,CAAC,CAAE,EACnC,CAAC,EAAA,qBAAqB,CAAC,SAAS,CAAC,CAAE,EACnC,CAAC,EAAA,qBAAqB,CAAC,YAAY,CAAC,CAAE,CAC1C,EACA,GAAI,EAAiB,CACjB,IAAM,EAAa,IAAoB,EAAA,qBAAqB,CAAC,SAAS,EAAI,EACpE,EAAc,IAAoB,EAAA,qBAAqB,CAAC,SAAS,EAAI,EACrE,EAAiB,IAAoB,EAAA,qBAAqB,CAAC,YAAY,EAAI,SAEjF,AAAM,GAAc,CAAhB,CAAC,CAA8B,EAGd,CAAA,EAAA,EAAA,IAAA,AAAK,EAAC,CAHsB,CAGtB,EAHyB,MAGhB,CAAE,CAClC,SAAU,CACQ,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,OAAQ,CACvB,KAAM,SACN,QAAS,SACb,IACA,EAIA,CAAe,CAAC,EAAgB,CAExC,AADK,GAbM,CAef,CACA,OAAO,CACX,CACA,YAAY,CAAK,CAAC,CACd,KAAK,CAAC,GACN,IAAI,CAAC,CAZgC,IAY3B,CAAG,CACT,WAbkD,UAajC,CAb4C,CAc7D,EAdgE,IAAA,WAc9C,EAAM,QAAQ,AACpC,CACJ,CACJ,CACO,SAAS,EAA2B,CAAK,EAC5C,GAAI,IAnBwE,EAAC,IAmBvE,CAAQ,GAnBuE,QAmBrE,CAAS,cAAE,CAAY,UAAE,CAAQ,CAAE,CAAG,EAKhD,EAAW,IACX,EAAe,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,kBAAkB,SACtB,AAC5B,GADwC,CACpC,EADiD,EAE5B,CAAA,EAAA,EAAA,GAAI,AAAJ,EAFwC,AAEnC,EAAiC,CACvD,CAFc,QAEJ,EACV,SAAU,EACV,UAAW,EACX,aAAc,EACd,aAAc,EACd,SAAU,CACd,GAEiB,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAA,QAAS,CAAE,CACjC,SAAU,CACd,EACJ,EAEA,0CAA0C,SEpH1C,IAAA,EAAA,EAAA,CAAA,CAAA,OgBWe,EAA6B,SAAS,CAAY,EAI7D,CAJ0B,MAC1B,EAAa,GADwB,CACjB,CAAG,KAAX,EACZ,EAAa,IAAO,CAAG,KAAX,EACZ,EAAa,SAAY,CAAG,AAAhB,YACL,CACX,EAAE,CAAC,GhBdH,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,MIFA,EAAA,EAAA,CAAA,CAAA,OQEO,IAAM,EAAgC,yBAChC,EAA8B,uBAQ9B,EAAW,WASX,EAAuB,OejB7B,SAAS,EAAwB,CAAM,EAEtC,MAAM,OAAO,cAAc,CAAC,AAAI,MAAM,2EAA4E,oBAAqB,CACnI,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAGR,CMZO,eAAe,EAAW,CAAQ,CAAE,CAAU,EACjD,OAAO,IAAI,QAAQ,CAAC,EAAS,KACzB,CAAA,EAAA,EAAA,eAAe,AAAf,EAAgB,KACZ,EAAwB,CACpB,KjBDoB,CiBCd,wBACN,aACA,UACA,SACA,CACJ,EACJ,EACJ,EACJ,ChCbO,CgCeP,GhCfa,EAiBT,OaJS,EAAmB,EbMhC,MAnBgC,G+BgGzB,SAAS,EAA4B,CAAG,EAC3C,IAAM,AClFiC,EDkFJ,IAAI,IAAI,GAE3C,GADA,C/BlGqE,C+BkG1C,M/B/EoB,M+B+ER,CAAC,MAAM,CAAC,GAEU,EAA2B,QAAQ,CAAC,CADlD,OAC0D,CAAC,QAAS,CACvG,GAAM,UAAE,CAAQ,CAAE,CAAG,EACf,EAAS,EAAS,QAAQ,CAAC,cAAgB,GAAK,EAEtD,EAA2B,QAAQ,CAAG,EAAS,KAAK,CAAC,EAAG,CAAC,EAC7D,CAEJ,OAAO,CACX,C5BlGA,IAAM,EAA2B,EAAA,wBAA+B,CAChE,SAAS,EAAgB,CAAG,EACxB,MAAO,CACH,WAAY,EAA4B,IAAI,IAAI,EAAK,SAAS,MAAM,GAAG,QAAQ,GAC/E,kBAAc,EACd,oBAAoB,EACpB,YAAa,GACb,UAAW,GACX,UAAW,CAAC,CAChB,CACJ,CACA,IAAI,EAAkB,IAAI,gBAkBf,eAAe,EAAoB,CAAG,CAAE,CAAO,MAuB9C,IA6KiC,EAnMzC,GAAM,OAmM+C,YAnM7C,CAAiB,SAAE,CAAO,cAAE,CAAY,CAAE,CAAG,EAC/C,EAAU,CQ3CM,IR6CJ,IAEd,CAAC,EAA8B,CgCInC,AhCJ2F,CAAtD,CAA8D,EgCI/F,UhCJ2G,CgCKpG,GADO,gBACY,KAAK,SAAS,CAAC,AhCL2B,IgCOjE,mBAAmB,KAAK,SAAS,CAAC,AAKzC,SAAS,EAAyC,CAAiB,QAsC9B,EArCrC,GAAM,CAAC,EAAS,EAAgB,EAAM,CAqCY,CArCG,EAAc,EAAmB,CAAG,EANP,AAS5E,EAyBiB,AAAvB,UAAI,KAzBmB,EAwBmB,AAC/B,EAzB6C,IAyBrB,CADc,CACN,UAAU,CAAC,EAAmB,KAC9D,CADoE,CAGxE,EA1BD,EAAwB,CAAC,EAC/B,IAAK,GAAM,CAAC,EAAK,EAAW,GAAI,OAAO,OAAO,CAAC,GAC3C,CAAqB,CAAC,EAAI,CAAG,EAAyC,GAE1E,GAH+D,CAGzD,EAAS,CACX,EACA,EACA,KA0BW,AAzBX,GAA4B,IAyBkB,YAAlB,EAzBiB,EAAgB,KAChE,CAQD,OANqB,AAAjB,WAA4B,CAC5B,EAAM,CAAC,EAAE,CAAG,CAAA,EAEZ,AAAuB,WAAW,EAClC,CAAM,CAAC,EAAE,CAAG,CAAA,EAET,CACX,MhCnCI,EAMM,IAAiB,EAAa,IAAI,EAAE,CACtC,CAAO,CAAC,EAA4B,CAAG,GAAA,EAKvC,IACA,CAAO,CAAC,EAAS,CADR,AACW,CAAA,EAExB,GAAI,CAMA,IAAM,EAAgB,EAAe,IAAiB,EAAa,SAAS,CAAG,OAAS,MAAQ,OAOpF,CADJ,EAAM,IAAI,IAAI,EAAA,EACN,QAAQ,CAAC,QAAQ,CAAC,KACtB,CAD4B,CACxB,QAAQ,EAAI,YAEhB,EAAI,QAAQ,EAAI,OAI5B,IAAM,EAAM,MAAM,EAAY,EAAK,EAAS,EAAe,EAAgB,MAAM,EAC3E,EAAc,EAA4B,IAAI,IAAI,EAAI,GAAG,GACzD,EAAe,EAAI,UAAU,CAAG,OAAc,EAC9C,EAAc,EAAI,OAAO,CAAC,GAAG,CAAC,iBAAmB,GACjD,EAAe,CAAC,CAAC,CAAC,AAAgD,MAA/C,GAAmB,EAAI,OAAO,CAAC,GAAG,CAAC,OAAA,CAAO,CAAY,KAAK,EAAI,EAAiB,QAAQ,CAAC,EAAA,CAAS,CACrH,EAAY,CAAC,CAAC,EAAI,OAAO,CAAC,GAAG,CQ/DH,AR+DI,sBAC9B,EAAyB,EAAI,OAAO,CAAC,GAAG,CQjET,ARiEU,uBACzC,EAAuC,OAA3B,EAAyE,IAAvC,SAAS,EAAwB,IAAa,CAAC,EAC/F,EAAmB,EAAY,UAAU,CQ5Ed,AR4Ee,oBAU9C,GATA,AAEa,GAF8B,CAG/B,EAAmB,EAAY,UADZ,AACsB,CAAC,aAAA,EAMlD,CAAC,GAAoB,CAAC,EAAI,EAAE,EAAI,CAAC,EAAI,IAAI,CAKzC,CAL2C,MAEvC,EAAI,IAAI,EAAE,AACV,GAAY,IAAI,CAAG,EAAI,IAAA,AAAI,EAExB,EAAgB,EAAY,QAAQ,IAU/C,IAAM,EAAe,EAAY,AA+HzC,SAAS,AAA8B,CAAoB,EAYvD,IAAM,EAAS,EAAqB,SAAS,GAC7C,OAAO,IAAI,eAAe,CACtB,MAAM,KAAM,CAAU,EAClB,MAAM,CAAK,CACP,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAAO,IAAI,GACzC,GAAI,CAAC,EAAM,CAGP,EAAW,OAAO,CAAC,GACnB,QACJ,CAGA,MACJ,CACJ,CACJ,EACJ,EAEA,AA9JuE,EAAI,IAAI,EAAI,EAAI,IAAI,CAC7E,EAAW,MAAM,GAA6B,EAyHjD,EAAyB,EAAc,CAC1C,WAAA,EACA,GAkCyC,cAlCzC,CACJ,IA3HI,GAAI,AF1GQ,KE0GY,EAAS,CAAC,CAC9B,CADgC,MACzB,EAAgB,EAAI,GAAG,EAElC,MAAO,CACH,UAAA,EgCxFwB,AhCwFZ,EAAoB,EAAS,CAAC,CgCrFxB,AAA1B,IAH0C,MAGN,AAAhC,OAAO,EACA,EAEJ,EAAW,GAAG,CAAC,AAAC,GAAiB,CAnCrC,SAAS,AAA2B,CAAc,MAOjD,EAHJ,GAAM,CAAC,EAAM,EAAU,EAAM,EAAc,CAAG,EAAe,KAAK,CAAC,CAAC,GAE9D,EAAc,EAAe,KAAK,CAAC,EAAG,CAAC,GAE7C,MAAO,CAIH,cAAe,EAAY,KAAK,CAAC,EAAG,CAAC,eACrC,EAGA,QAAkE,AAAzD,OAAC,EAAgB,CAAW,CAAC,EAAY,MAAM,CAAG,EAAA,AAAE,EAAY,EAAgB,QACzF,WACA,OACA,gBACA,EACA,aAnByB,IAmBX,EAAe,MAAM,AACvC,EACJ,EAYuE,CAdvB,IhCiGpC,aAAc,EACd,mBAAoB,EACpB,YAAa,EAAS,CAAC,WACvB,EACA,WACJ,CACJ,CAAE,MAAO,EAAK,CAOV,OANI,AAAC,EAAgB,MAAM,CAAC,OAAO,EAAE,AACjC,QAAQ,KAAK,CAAC,mCAAqC,EAAM,wCAAyC,GAK/F,CACH,WAAY,EAAI,QAAQ,GACxB,kBAAc,EACd,oBAAoB,EACpB,aAAa,EACb,WAAW,EACX,UAAW,CAAC,CAChB,CACJ,CACJ,CACO,eAAe,EAAY,CAAG,CAAE,CAAO,CAAE,CAAa,CAAE,CAAM,EAoBjE,IAAI,EAAW,IAAI,IAAI,EDlJvB,QoBnB2D,EAAuB,EAAiB,EpBoChD,ECkIxB,EDlI6B,GoBpCb,EpBkBW,CAAO,CoBlBoC,AAAe,ApBkBlD,EAA4B,EoBlBV,CpBkBY,CAAO,CSRpD,ATQqD,GoBlB3C,ApBmBtB,KAAK,uBADgG,GAAE,CAAO,CAAC,EAA8B,GAAE,ACoJ7I,CDpJoJ,CAAC,EAAS,CoBjBnM,AAAI,CAAC,AAAmB,YAAgC,MAAnB,CAAmB,CAAG,OAA+B,IAA1B,QAA2D,IAApB,QAAmD,IAAlB,EAC7H,GgBaJ,AATJ,EhBLkK,OgBcrJ,AATJ,CAAS,CAAG,EACxB,IAAI,EAAO,KACX,IAAI,IAAI,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAE3B,AAF+B,EAExB,CAAC,IAAQ,CAAC,CAAI,EADR,EAAI,GACW,OADD,CAAC,GACO,EAEvC,OAAO,IAAS,EACpB,EhBTmB,CACX,GAAkB,IAClB,GAAyB,IACzB,GAAmB,IACnB,GAAiB,IACpB,CAAC,IAAI,CAAC,MgBMc,QAAQ,CAAC,IAAI,KAAK,CAAC,EAAG,IpCgCzC,IAAM,EAAiB,EAAI,MAAM,CAI7B,EAAQ,CAHG,EAAe,UAAU,CAAC,KAAO,EAAe,KAAK,CAAC,GAAK,CAAA,EAGrD,KAAK,CAAC,KAAK,MAAM,CAAC,AAAC,GAAO,GAAQ,CAAC,EAAK,UAAU,CAAC,GAAK,EAAuB,MAClG,EAAK,MAAM,CAAG,EACd,CADiB,CACX,IAAI,CAAC,EAAuB,IAAM,GAExC,EAAM,IAAI,CAAC,GAAK,GAEpB,EAAI,MAAM,CAAG,EAAM,MAAM,CAAG,IAAM,EAAM,IAAI,CAAC,KAAO,EAtCZ,CCoJxC,IAAI,EAAkB,MAAM,MAAM,EAZb,CAEjB,OAUwC,KAV3B,sBACb,EACA,SAAU,QAAiB,SAC3B,CACJ,GA4BI,EAAa,EAAgB,UAAU,CA4BrC,EAAc,IAAI,IAAI,EAAgB,GAAG,CAAE,GAiBjD,OAhBA,AAgBO,EAhBK,YAAY,CAAC,MAAM,CAAC,GACZ,CAChB,IAAK,EAAY,IAAI,YAKrB,EAIA,GAAI,EAAgB,EAAE,CACtB,QAAS,EAAgB,OAAO,CAChC,KAAM,EAAgB,IAAI,CAC1B,OAAQ,EAAgB,MAAM,AAClC,CAEJ,C2B1OW,IAAM,EAAqB,CAClC,KAAM,KAAK,CACf,GAEA,OzBHA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,ODJA,IAAM,EAAmD,EAAA,CAAA,CAAA,I0BMV,G1BNyE,MAA/F,UAA+G,CAIjI,EAJoI,OAI3H,EAAe,CAAK,EAChC,GAAI,OAAE,CAAK,CAAE,CAAG,EAChB,GAAI,EAAkB,CAClB,IAAM,EAAQ,EAAiB,QAAQ,GACvC,GAAI,AAAC,CAAS,QAAO,KAAK,EAAI,EAAM,YAAA,AAAY,IAAM,AAAS,CAAV,OAAiB,KAAK,EAAI,EAAM,kBAAA,AAAkB,EAEnG,CAFsG,KACtG,QAAQ,KAAK,CAAC,GACR,CAEd,CACA,OAAO,IACX,C8BVsC,AdEO,ChBU7C,4CAA4C,yQgBVwB,CcApE,KdA0E,AfGnE,OAAM,UAA6B,EAAA,OAAK,CAAC,K6BHX,I7BGoB,CACrD,OAAO,yBAAyB,CAAK,CAAE,CACnC,GAAI,CAAA,EAAA,EAAA,iBAAA,AAAiB,EAAC,GAGlB,KAH0B,CAGpB,EAEV,MAAO,OACH,CACJ,CACJ,CACA,OAAO,yBAAyB,CAAK,CAAE,CAAK,CAAE,CAC1C,GAAM,CAAE,OAAK,CAAE,CAAG,SAmBlB,AAAI,EAAM,QAAQ,GAAK,EAAM,gBAAgB,EAAI,EAAM,KAAK,CACjD,CADmD,AAEtD,MAAO,KACP,iBAAkB,EAAM,QAAQ,AACpC,EAEG,CACH,MAAO,EAAM,KAAK,CAClB,iBAAkB,EAAM,QAAQ,AACpC,CACJ,CAEA,QAAS,QAGL,AAAI,IAAI,CAAC,KAAK,CAAC,KAAK,EAAI,CAAC,CACA,CAAA,EAAA,EAAA,IAAA,AAAK,EAAC,EAAA,EADU,MACD,CAAE,CAClC,SAAU,CACQ,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAgB,CAC/B,MAAO,IAAI,CAAC,KAAK,CAAC,KAAK,AAC3B,GACA,IAAI,CAAC,KAAK,CAAC,WAAW,CACtB,IAAI,CAAC,KAAK,CAAC,YAAY,CACT,CAAA,EAAA,EAAA,GAAI,AAAJ,EAAK,IAAI,CAAC,KAAK,CAAC,cAAc,CAAE,CAC1C,MAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CACvB,MAAO,IAAI,CAAC,KAAK,AACrB,GACH,AACL,GAEG,IAAI,CAAC,KAAK,CAAC,QAAQ,AAC9B,CACA,YAAY,CAAK,CAAC,CACd,KAAK,CAAC,GAAQ,IAAI,CAAC,KAAK,CAAG,KACvB,IAAI,CAAC,QAAQ,CAAC,CACV,MAAO,IACX,EACJ,EACA,IAAI,CAAC,KAAK,CAAG,CACT,MAAO,KACP,iBAAkB,IAAI,CAAC,KAAK,CAAC,QAAQ,AACzC,CACJ,CACJ,CAOW,SAAS,EAAc,CAAK,EACnC,GAAI,gBAAE,CAAc,aAAE,CAAW,cAAE,CAAY,UAAE,CAAQ,CAAE,CAAG,EAKxD,EAAW,CAAA,EAAA,EAAA,oBAAA,AAAoB,WACrC,AAAI,EACqB,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAsB,CAC5C,CAFY,QAEF,EACV,eAAgB,EAChB,YAAa,EACb,aAAc,EACd,SAAU,CACd,GAEiB,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAA,QAAS,CAAE,CACjC,SAAU,CACd,EACJ,CS7GO,CT+GP,GS/Ga,EAAe,CAAC,EAAiB,IAE1C,AAA+B,UAA3B,AAAqC,OAA9B,EACP,AAAuB,UAAnB,AAA6B,CT4GC,MS5GvB,GAEA,IAAoB,EAInC,AAAuB,UAAnB,AAA6B,OAAtB,GAGJ,CAAe,CAAC,EAAE,GAAK,CAAO,CAAC,EAAE,EAAI,CAAe,CAAC,EAAE,GAAK,CAAO,CAAC,EAAE,CRZjF,EAAA,CAAA,CAAA,cqBEA,EAAA,CAAA,CAAA,OpBFA,EAAA,CAAA,CAAA,MACA,IAAA,EAAA,EAAA,CAAA,CAAA,OAC2D,EAAA,CAAA,CAAA,OAAiE,kBAAkB,CCF9I,EDEiJ,ECFjJ,EAAA,EAAA,CAAA,CAAA,MAcwB,GAAA,8BAA8B,CUD9B,EAAA,AVCiC,8BUDH,CCC9B,EAAA,ADDiC,8BCCH,CkBRc,ElBQX,AkBRW,CAAA,CAAA,OAAqC,gBAAgB,CVuFlH,EUvFqH,OVuF5G,IACZ,IAAM,EAAS,CAAA,EAAA,EAAA,GUtFnB,OVsF6B,AAAV,EAAW,EAAA,gBAAgB,EAC1C,GAAe,MAAM,CAAjB,EACA,GUxFoC,GVwF9B,OAAO,cAAc,CAAC,AAAI,MAAM,+CAAgD,oBAAqB,CACvG,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,OAAO,CACX,CjBjGA,SAAS,EAAe,CAAK,EACzB,GAAI,UAAE,CAAQ,OAAE,CAAK,cAAE,CAAY,CAAE,CAAG,EAClC,EAAS,IAgBf,MAfA,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACN,EAAA,OAAK,CAAC,eAAe,CAAC,KACd,IAAiB,EAAA,YAAY,CAAC,IAAI,CAClC,CADoC,CAC7B,IAAI,CAAC,EAAU,CAAC,GAEvB,EAAO,OAAO,CAAC,EAAU,CAAC,GAE9B,GACJ,EACJ,EAAG,CACC,EACA,EACA,EACA,EACH,EACM,IACX,CDpBsC,gBkBqEtC,EAAA,CAAA,CAAA,OApE8D,EAAA,CAAA,CAAA,OAAqD,qBAAqB,AjBoBjI,GiBpBoI,IjBoB9H,UAA8B,EAAA,OAAK,CAAC,SAAS,CACtD,OAAO,yBAAyB,CAAK,CAAE,CACnC,GAAI,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,GAGhB,KAHwB,CAGjB,CACH,SHYZ,AAAK,CAAA,AGZiB,EHYjB,CAAD,CAAC,eAAA,AAAe,EAAC,GAGd,AGlBqC,EHkB/B,GAHgB,GAGV,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,EAAG,CAAC,GAAG,IAAI,CAAC,KAHb,KGXxB,aHgBT,AGnB0B,SHmBQ,AAAzB,CAA8B,EAC1C,GAAI,CAAC,CAAA,EAAA,EAAA,eAAe,AAAf,EAAgB,GACjB,KADyB,CACnB,OAAO,cAAc,CAAC,AAAI,MAAM,wBAAyB,oBAAqB,CAChF,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,OAAO,EAAM,MAAM,CAAC,KAAK,CAAC,IAAK,EAAE,CAAC,EAAE,AACxC,EG5B0D,EAI9C,CAGJ,OAAM,CACV,CAEA,QAAS,CACL,GAAM,CAAE,UAAQ,cAAE,CAAY,CAAE,CAAG,IAAI,CAAC,KAAK,QAC5B,AAAjB,AAAI,UAAsC,MAAM,CAAvB,EACA,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAgB,CACtC,SAAU,EACV,aAAc,EACd,MAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,CACjB,SAAU,IACd,EACR,GAEG,IAAI,CAAC,KAAK,CAAC,QAAQ,AAC9B,CACA,YAAY,CAAK,CAAC,CACd,KAAK,CAAC,GACN,IAAI,CAAC,KAAK,CAAG,CACT,SAAU,KACV,aAAc,IAClB,CACJ,CACJ,CACO,SAAS,EAAiB,CAAK,EAClC,GAAI,UAAE,CAAQ,CAAE,CAAG,EACb,EAAS,IACf,MAAqB,CAAd,AAAc,EAAA,EAAA,GAAA,AAAI,EAAC,EAAuB,AAA/B,CACd,OAAQ,EACR,SAAU,CACd,EACJ,CXxDA,CW0DA,GX1DA,EAAA,EAAA,CAAA,CAAA,OyBXO,SAAS,EAAqB,CAAO,CAAE,CAAuB,QAIjE,CAHI,AAA4B,KAAK,CdoEI,OcpED,GAA0B,CAAA,EAG9D,MAAM,OAAO,CAAC,IACP,CAAO,CAAC,EAAE,CAAG,CADI,GACE,CAAO,CAAC,EAAE,CAAG,IAAM,CAAO,CAAC,EAAE,CAIvD,GAA2B,EAAQ,UAAU,CAAC,GACvC,EAEJ,CACX,CIZO,CJcP,GIda,EAA6B,CACtC,KJOqE,MINrE,MACA,OACA,QACH,A7BgDoE,GAAA,OAAQ,CAAC,EyBvC3B,0DzBuCuF,CAY1I,IAAM,EAAiB,CACnB,SACA,SACA,OACA,QACA,MACA,QACA,IACA,IACH,CAuBG,SAAS,EAAuB,CAAO,CAAE,CAAc,EACvD,IAAM,EAAO,EAAQ,qBAAqB,GAC1C,OAAO,EAAK,GAAG,EAAI,GAAK,EAAK,GAAG,EAAI,CACxC,CAgBA,MAAM,UAAmC,EAAA,OAAK,CAAC,SAAS,CACpD,mBAAoB,CAChB,IAAI,CAAC,qBAAqB,EAC9B,CACA,oBAAqB,CAEb,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,KAAK,EAAE,AACpC,IAAI,CAAC,qBAAqB,EAElC,CACA,QAAS,CACL,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,AAC9B,CACA,YAAY,GAAG,CAAI,CAAC,CAChB,KAAK,IAAI,GAAO,IAAI,CAAC,qBAAqB,CAAG,KAEzC,GAAM,CAAE,mBAAiB,aAAE,CAAW,CAAE,CAAG,IAAI,CAAC,KAAK,CACrD,GAAI,EAAkB,KAAK,CAAE,CAIzB,GAA8C,IAA1C,EAAkB,YAAY,CAAC,MAAM,EAAU,CAAC,EAAkB,YAAY,CAAC,IAAI,CAAC,AAAC,GAAuB,EAAY,KAAK,CAAC,CAAC,EAAS,IAAQ,EAAa,EAAS,CAAoB,CAAC,EAAM,IACjM,CADsM,MAG1M,IAAI,EAAU,KACR,EAAe,EAAkB,YAAY,CAUnD,GATI,IACA,EArChB,AAqC0B,QADI,CApCrB,AAAuB,CAAY,MAKxC,QAHJ,AAAI,AAAiB,OAAO,GACjB,SAAS,IAAI,CAIqD,AAAtE,OAAC,EAA2B,SAAS,cAAc,CAAC,EAAA,CAAa,CAAY,EACpF,SAAS,iBAAiB,CAAC,EAAa,CAAC,EAC7C,AAD+C,EA6BM,EAAA,EAIjC,AAAC,IACD,EAzF0B,GAwFhB,CACgB,EAG1B,CAAC,AAAC,CAHQ,YAAY,CAGD,OAAA,CAAO,CAC5B,EAD+B,KAKnC,KAAM,CAAC,CAAC,aAAmB,WAAA,CAAW,EA/ElD,AA+EuD,SA/E9C,AAAkB,CAAO,EAIlC,GAAI,CACA,SACA,QACH,CAAC,QAAQ,CAAC,iBAAiB,GAAS,QAAQ,EAIzC,CAJ4C,MAIrC,EAIX,IAAM,EAAO,EAAQ,qBAAqB,GAC1C,OAAO,EAAe,KAAK,CAAC,AAAC,GAAsB,IAAf,CAAI,CAAC,EAAK,CAClD,EA8D6E,IAAS,CAUlE,GAAmC,MAAM,CAArC,EAAQ,kBAAkB,CAC1B,OAEJ,EAAU,EAAQ,kBAAkB,AACxC,CAEA,EAAkB,KAAK,CAAG,GAC1B,EAAkB,YAAY,CAAG,KACjC,EAAkB,YAAY,CAAG,EAAE,CO5KxC,AP6KK,SO7KI,AAAyC,CAAE,CAAE,CAAO,EAIpE,GAHgB,KAAK,IAAjB,IAAoB,EAAU,EAAC,EAG/B,EAAQ,cAAc,CAAE,OACxB,IAGJ,IAAM,EAAc,SAAS,eAAe,CACnB,EAAY,OAAO,CAAC,cAAc,CAkB3D,IAlBgE,AAkB1D,EAAW,EAAY,KAAK,CAAC,cAAc,CACjD,EAAY,KAAK,CAAC,cAAc,CAAG,OAC9B,AAAD,EAAS,eAAe,EAAE,AAI1B,EAAY,cAAc,GAE9B,IACA,EAAY,KAAK,CAAC,cAAc,CAAG,CACvC,EAEA,APsIyD,KAErC,GAAI,EAAc,YAEd,EAAQ,cAAc,GAK1B,IAAM,EAAc,EO/IS,OP+IA,eAAe,CACtC,EAAiB,EAAY,YAAY,EAE3C,EAAuB,EAAS,KAOpC,EAAY,SAAS,CAPgC,AAO7B,EAEpB,AAAC,EAAuB,EAAS,IAGjC,EAAQ,WAH0C,GAG5B,GAE9B,EAAG,CAEC,iBAAiB,EACjB,eAAgB,EAAkB,cAAc,AACpD,GAEA,EAAkB,cAAc,CAAG,GAEnC,EAAQ,KAAK,EACjB,CACJ,CACJ,CACJ,CACA,SAAS,EAAsB,CAAK,EAChC,GAAI,aAAE,CAAW,UAAE,CAAQ,CAAE,CAAG,EAC1B,EAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,yBAAyB,EACpD,GAAI,CAAC,EACD,MAAM,CADI,MACG,cAAc,CAAC,AAAI,MAAM,8CAA+C,oBAAqB,CACtG,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,GAEJ,MAAqB,CAAd,AAAc,EAAA,EAAA,GAAA,AAAI,EAAC,EAA4B,AAApC,CACd,YAAa,EACb,kBAAmB,EAAQ,iBAAiB,CAC5C,SAAU,CACd,EACJ,CAGI,SAAS,EAAkB,CAAK,EAChC,GAAI,MAAE,CAAI,CAAE,aAAW,WAAE,CAAS,KAAE,CAAG,CAAE,CAAG,EACtC,EAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,yBAAyB,EACpD,GAAI,CAAC,EACD,MAAM,CADI,MACG,cAAc,CAAC,AAAI,MAAM,8CAA+C,oBAAqB,CACtG,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,GAEJ,GAAM,CAAE,KAAM,CAAQ,CAAE,CAAG,EAOrB,EAAgD,OAA1B,EAAU,WAAW,CAAY,EAAU,WAAW,CAAG,EAAU,GAAG,CAI5F,EAAM,CAAA,EAAA,EAAA,gBAAA,AAAgB,EAAC,EAAU,GAAG,CAAE,GAKtC,EAA6B,UAAf,OAAO,GAA4B,OAAR,GAAoC,YAApB,OAAO,EAAI,IAAI,CAAkB,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,GAAO,EAC3G,GAAI,CAAC,EAAa,CAKd,IAAI,EAAW,EAAU,QAAQ,CACjC,GAAI,AAAa,SAAM,CAInB,IAAM,EAAc,AAzP5B,SAAS,EAAe,CAAiB,CAAE,CAAc,EACzD,GAAI,EAAmB,CACnB,GAAM,CAAC,EAAS,EAAiB,CAAG,EAC9B,EAAsC,IAA7B,EAAkB,MAAM,CACvC,GAAI,EAAa,CAAc,CAAC,EAAE,CAAE,IAC5B,CAAc,CAAC,EAAE,CAAC,CADoB,aACN,CAAC,GAAmB,CACpD,GAAI,EAAQ,CACR,IAAM,EAAU,OAAe,EAAW,CAAc,CAAC,EAAE,CAAC,EAAiB,EAC7E,MAAO,CACH,CAAc,CAAC,EAAE,CACjB,CACI,GAAG,CAAc,CAAC,EAAE,CACpB,CAAC,EAAiB,CAAE,CAChB,CAAO,CAAC,EAAE,CACV,CAAO,CAAC,EAAE,CACV,CAAO,CAAC,EAAE,CACV,UACH,AACL,EACH,AACL,CACA,MAAO,CACH,CAAc,CAAC,EAAE,CACjB,CACI,GAAG,CAAc,CAAC,EAAE,CACpB,CAAC,EAAiB,CAAE,EAAe,EAAkB,KAAK,CAAC,GAAI,CAAc,CAAC,EAAE,CAAC,EAAiB,CACtG,EACH,AACL,CAER,CACA,OAAO,CACX,EAyN+C,CAC/B,MACG,EACN,CAAE,GACG,E0BlRX,A1BkR4B,S0BlRnB,EAAkC,CAAK,EACnD,GAAI,CAAC,EAAS,EAAe,CAAG,EAEhC,GAAI,MAAM,OAAO,CAAC,IAAa,CAAe,OAAhB,CAAQ,CAAC,EAAE,EAA4B,OAAf,CAAO,CAAC,EAAE,AAAK,CAAI,EAIlD,CAJqD,SAIxE,EAA+B,KAAxB,QGE6F,IHF1C,AGEvD,EAAK,KAAK,CAAC,EHFsD,GGEjD,IAAI,CAAE,AAAD,GAAW,EAA2B,IAAI,CAAC,AAAC,GAAI,EAAQ,UAAU,CAAC,KHL3F,OAAO,EAOX,GAAI,GACA,IAAI,IAAM,KADM,AACC,EACb,GAAI,EAAkC,CAAc,CAAC,EAAI,EACrD,CADwD,CADhC,KAEjB,CAEf,CAEJ,OAAO,CACX,E1B+PqE,A0B7PrE,G1B8PkB,EAAc,KAAK,GAAG,GAC5B,EAAU,QAAQ,CAAG,EAAW,EAAoB,IAAI,IAAI,EAAK,SAAS,MAAM,EAAG,CAC/E,O0BhQkD,W1BgQ/B,EACnB,QAAS,EAAiB,EAAQ,OAAO,CAAG,IAChD,GAAG,IAAI,CAAC,AAAC,IACL,CAAA,EAAA,EAAA,eAAA,AAAe,EAAC,KACZ,EAAwB,CACpB,KgBxRW,ChBwRL,cACN,aAAc,iBACd,cACA,CACJ,EACJ,GACO,IAGX,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EACR,CAGA,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EACR,CAcA,MAXc,CAWP,AAXO,EAAA,EAAA,GAAA,AAAI,EAAC,EAAA,mBAAmB,CAAC,QAAQ,CAAE,CAC7C,MAAO,CACH,WAAY,EACZ,gBAAiB,EACjB,kBAAmB,EAEnB,IAAK,CACT,EACA,SAAU,CACd,EAGJ,CAII,SAAS,EAAgB,CAAK,EAC9B,IASI,EATA,CAAE,SAAO,UAAE,CAAQ,CAAE,CAAG,EAgB5B,GAJI,CAIA,CANmB,UAAnB,OAAO,GAAoC,OAAZ,GAAoB,AAAwB,YAAY,OAA7B,EAAQ,IAAI,CAElD,CAAA,EAAA,EAAA,GAAA,AAAG,EADG,AACF,GAEJ,EAED,CACnB,IAAM,EAAa,CAAiB,CAAC,EAAE,CACjC,EAAgB,CAAiB,CAAC,EAAE,CACpC,EAAiB,CAAiB,CAAC,EAAE,CAC3C,MAAqB,CAAd,AAAc,EAAA,EAAA,GAAA,AAAI,EAAC,EAAA,AAAR,QAAgB,CAAE,CAChC,SAAwB,CAAd,AAAc,EAAA,EAAA,IAAA,AAAK,EAAC,CAAT,CAAS,QAAS,CAAE,CACrC,SAAU,CACN,EACA,EACA,EACH,AACL,GACA,SAAU,CACd,EACJ,CACA,MAAqB,CAAd,AAAc,EAAA,EAAA,GAAA,AAAI,EAAC,EAAA,AAAR,QAAiB,CAAE,CACjC,SAAU,CACd,EACJ,CAImB,SAAS,EAAkB,CAAK,EAC/C,GAAI,mBAAE,CAAiB,OAAE,CAAK,aAAE,CAAW,cAAE,CAAY,CAAE,gBAAc,iBAAE,CAAe,UAAE,CAAQ,UAAE,CAAQ,WAAE,CAAS,CAAE,cAAY,uBAAE,CAAqB,CAAE,CAAG,EAC7J,EAAU,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,mBAAmB,EAC9C,GAAI,CAAC,EACD,MAAM,CADI,MACG,cAAc,CAAK,AAAJ,MAAU,kDAAmD,oBAAqB,CAC1G,MAAO,MACP,YAAY,EACZ,cAAc,CAClB,GAEJ,GAAM,CAAE,YAAU,iBAAE,CAAe,mBAAE,CAAiB,KAAE,CAAG,CAAE,CAAG,EAG1D,EAAuB,EAAgB,cAAc,CACvD,EAAa,EAAqB,GAAG,CAAC,GAGrC,IACD,EAAa,IAAI,EADJ,EAEb,EAAqB,GAAG,CAAC,EAAmB,IAEhD,IAAM,EAAoB,CAAU,CAAC,EAAE,CACjC,EAAoC,OAAtB,AACpB,EACA,CACI,EACH,CAAG,EAAkB,MAAM,CAAC,CACzB,EACA,EACH,EAWK,EAAa,CAAU,CAAC,EAAE,CAAC,EAAkB,CAE7C,EAAiB,EADD,CAAU,AAlBK,CAkBJ,EAAE,EACwB,GAQvD,EsB/XG,AtB+XY,CAR8C,OAArB,CsBvX5B,AAAiB,CAAU,CAAE,CAAc,EAU3D,GAAM,CAAC,EAAiB,AtB6W4D,EsB7WzC,CAAG,CAAA,EAAA,EAAA,QAAA,AAAQ,EAAC,KAC9B,CACjB,KAAM,EACN,SAAU,EACV,KAAM,KACV,GAGJ,GAAI,EAAgB,IAAI,GAAK,EAGzB,OAAO,EAUX,CAbyC,GAanC,EAAiB,CACnB,KAAM,EACN,SAAU,EACV,KAAM,IACV,EAII,EAAI,EACJ,EAAW,EACX,EAAc,EAClB,KAAmB,OAAb,GAAqB,EA9DuC,EA8DnC,CAAqB,CAChD,GAAI,EAAS,QAAQ,GAAK,EAAgB,CAQtC,EAAY,IAAI,CAAG,EAAS,IAAI,CAChC,KACJ,CAAO,CAEH,IACA,IAAM,EAAQ,CACV,KAAM,EAAS,IAAI,CACnB,SAAU,EAAS,QAAQ,CAC3B,KAAM,IACV,EACA,EAAY,IAAI,CAAG,EACnB,EAAc,CAClB,CACA,EAAW,EAAS,IAAI,AAC5B,CAEA,OADA,EAAmB,GACZ,CACX,EAEA,AtByTwC,EAAY,GAC5C,EAAW,EAAE,CACjB,EAAG,CACC,IAAM,EAAO,EAAa,IAAI,CACxB,EAAW,EAAa,KsB7TH,GtB6TW,CAEhC,EAAW,EADD,CAAI,CAAC,EAAE,EAGnB,EAAY,EAAW,GAAG,CAAC,GAC/B,EAHsC,MAGpB,IAAd,EAAyB,CAGzB,IAAM,EAAmB,CACrB,SAAU,KACV,IAAK,KACL,YAAa,KACb,KAAM,KACN,aAAc,KACd,eAAgB,IAAI,IACpB,QAAS,KACT,YAAa,CAAC,CAClB,EAEA,EAAY,EACZ,EAAW,GAAG,CAAC,EAAU,EAC7B,CA8BA,IAAM,EAAoB,EAAgB,OAAO,CAC7C,EAAsB,CAAA,EAAA,EAAA,CAAd,GAAc,AAAK,EAAC,EAAA,IAAT,WAAwB,CAAC,QAAQ,CAAE,CACtD,MAAqB,CAAd,AAAc,EAAA,EAAA,IAAA,AAAK,EAAC,CAAT,CAAgC,CAC9C,YAAa,EACb,SAAU,CACQ,CAAA,EAAA,EAAA,GAAI,AAAJ,EAAK,EAAe,CAC9B,eAAgB,EAChB,YAAa,EACb,aAAc,EACd,SAAwB,CAAd,AAAc,EAAA,EAAA,GAAA,AAAI,EAAC,EAAR,AAAyB,CAC1C,QAAS,EACT,SAAwB,CAAd,AAAc,EAAA,EAAA,GAAI,AAAJ,EAAK,EAAA,AAAR,0BAAkC,CAAE,CACrD,SAAU,EACV,UAAW,EACX,aAAc,EACd,SAAwB,CAAd,AAAc,EAAA,EAAA,IAAA,AAAK,EAAC,CAAT,CAA2B,CAC5C,SAAU,CACQ,CAAA,EAAA,EAAA,GAAA,AAAI,EAAC,EAAmB,CAClC,IAAK,EACL,KAAM,EACN,UAAW,EACX,YAAa,CACjB,GA1CF,KA6CN,AADK,EAET,EACJ,EACJ,GA/Ce,KAiDlB,AACL,GACA,SAAU,CACN,EACA,EACA,EACH,AACL,EAAG,GAgBH,EAAS,IAAI,CAAC,GACd,EAAe,EAAa,IAAI,AACpC,OAAyB,OAAjB,EACR,AAD+B,OACxB,CACX,EAEA,yCAAyC,uByCrgBzC,EAAmD,CAA5CoB,CAA4C,CAAA,CAAA,MAAnCC,CAChB,EAAgC,EAAA,CAAvBC,AAAuB,CAAA,GADN,GAGX,KAH6B,GACpB,CAEAC,EAF4D,EADjC,AAIjD,GAH8B,CAGxBC,EAAAA,CAAAA,EAAWH,EAAAA,UAAAA,EAAWC,EAAAA,eAAAA,EAC5B,MAAA,CAAA,EAAO,EAAA,GAAA,EAAA,EAAP,AAAO,QAAA,CAAA,UAAGE,GACZ,yEGRO,OAAM,EACT,OAAO,IAAI,CAAM,CAAE,CAAI,CAAE,CAAQ,CAAE,CAC/B,IAAM,EAAQ,QAAQ,GAAG,CAAC,EAAQ,EAAM,SACxC,AAAqB,YAAjB,AAA6B,OAAtB,EACA,EAAM,IAAI,CAAC,GAEf,CACX,CACA,OAAO,IAAI,CAAM,CAAE,CAAI,CAAE,CAAK,CAAE,CAAQ,CAAE,CACtC,OAAO,QAAQ,GAAG,CAAC,EAAQ,EAAM,EAAO,EAC5C,CACA,OAAO,IAAI,CAAM,CAAE,CAAI,CAAE,CACrB,OAAO,QAAQ,GAAG,CAAC,EAAQ,EAC/B,CACA,OAAO,eAAe,CAAM,CAAE,CAAI,CAAE,CAChC,OAAO,QAAQ,cAAc,CAAC,EAAQ,EAC1C,CACJ,EAEA,mCAAmC,6BFnBnC,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,IAAM,EAAW,CACb,QAAS,IACb,EAEM,EAA+B,YAAvB,OAAO,EAAA,KAAW,CAAkB,EAAA,KAAW,CAAG,AAAC,GAAK,EAIhE,EAAuE,QAAQ,IAAI,CAqB9E,EArBY,OAqBH,EAA4C,CAAU,EACtE,OAAO,SAAS,AAAgB,GAAG,CAAI,EAkB/B,EAjBY,EAvBqC,GAuBvB,GAmBlC,CACJ,CAxC+B,CA0C/B,CAzCC,AAAD,CAoC2B,GAnCvB,GAAI,CACA,EAAe,EAAS,OAAO,CACnC,QAAS,CACL,EAAS,OAAO,CAAG,IACvB,CACJ,6BAmC0E,8FCjD1E,IAAM,EAA+B,6BAC9B,SAAS,EAA6B,CAAM,CAAE,CAAI,SACrD,AAAI,EAA6B,IAAI,CAAC,GAC3B,IADkC,AAC5B,EAAS,IAAM,EAAO,IAEhC,IAAM,EAAS,IAAM,KAAK,SAAS,CAAC,GAAQ,IACvD,CACO,SAAS,EAAkC,CAAM,CAAE,CAAI,EAC1D,IAAM,EAAkB,KAAK,SAAS,CAAC,GACvC,MAAO,gBAAkB,EAAS,KAAO,EAAkB,QAAU,EAAkB,OAAS,EAAS,eAC7G,CACO,IAAM,EAAsB,IAAI,IAAI,CACvC,iBACA,gBACA,uBACA,WACA,UACA,iBAGA,OACA,QACA,UAGA,SAEA,cACA,aAGA,SACA,WACA,aACH,GAED,yCAAyC,uNGzCzC,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,ODNA,EAAA,EAAA,CAAA,CAAA,OASO,SAAS,EAAsD,CAAK,CAAE,CAAU,EACnF,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,qBAAqB,CAAC,CAAC,MAAM,EAAE,EAAM,4EAA4E,EAAE,EAAW,0HAA0H,CAAC,EAAG,oBAAqB,CAC7S,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,CACO,SAAS,EAAqC,CAAS,CAAE,CAAc,EAC1E,IAAM,EAAQ,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,MAAM,EAAE,EAAU,KAAK,CAAC,uXAAuX,CAAC,EAAG,oBAAqB,CACnd,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAGA,OAFA,MAAM,iBAAiB,CAAC,EAAO,GAC/B,EAAU,wBAAwB,GAAK,EACjC,CACV,CCjBO,SAAS,EAA6B,CAAsB,CAAE,CAAS,EAC1E,IAAM,EAAgB,EAAA,oBAAoB,CAAC,QAAQ,GACnD,GAAI,EACA,OAAO,EAAc,IADN,AACU,EACrB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACD,OAAO,EAAkC,EAAW,EACxD,KAAK,oBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,6EAA8E,oBAAqB,CAC9I,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,wEAAyE,oBAAqB,CACzI,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,KAAK,UACD,OAAO,EAAyB,EAAwB,EAGhE,CAEJ,CAAA,EAAA,EAAA,6BAA6B,AAA7B,GACJ,CDrCA,EAAA,CAAA,CAAA,OCuCO,IAAM,EAAsC,EAC5C,SAAS,EAAsC,CAAsB,CAAE,CAAS,EACnF,IAAM,EAAgB,EAAA,oBAAoB,CAAC,QAAQ,GACnD,GAAI,EACA,OAAO,EAAc,IADN,AACU,EACrB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACD,OAAO,EAAkC,EAAW,EACxD,KAAK,QACL,IAAK,gBACL,IAAK,iBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,iFAAkF,oBAAqB,CAClJ,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,EACJ,KAAK,0BAoEmD,EAnEpD,OAAO,AAmEqB,EAnEc,EAmEuB,EAnEC,EAoEvE,CAAA,EAAA,EAAA,SADuD,aACvD,AAAsB,EAAC,EAAyG,EAAgC,GAnE/J,KAAK,GAmEgC,OAlEjC,OAAO,EAAyB,EAAwB,EAGhE,CAEJ,CAAA,EAAA,EAAA,YA6DmF,iBA7DnF,AAA6B,GACjC,CACO,SAAS,EAAyC,CAAS,EAC9D,GAAI,EAAU,WAAW,CAGrB,CAHuB,MAGhB,QAAQ,OAAO,CAAC,CAAC,GAE5B,IAAM,EAAgB,EAAA,oBAAoB,CAAC,QAAQ,GACnD,GAAI,EACA,OAAO,EAAc,IADN,AACU,EACrB,IAAK,YACL,IAAK,mBAGD,MAAO,CAAA,EAAA,EAAA,kBAAA,AAAkB,EAAC,EAAc,YAAY,CAAE,EAAU,KAAK,CAAE,iBAC3E,KAAK,oBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,yFAA0F,oBAAqB,CAC1J,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,oFAAqF,oBAAqB,CACrJ,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,EACJ,KAAK,gBACL,IAAK,mBACL,IAAK,UACD,OAAO,QAAQ,OAAO,CAAC,CAAC,EAGhC,CAEJ,CAAA,EAAA,EAAA,6BAAA,AAA6B,GACjC,CACA,SAAS,EAAkC,CAAS,CAAE,CAAc,EAChE,GAAI,EAAU,WAAW,CAGrB,CAHuB,MAGhB,QAAQ,OAAO,CAAC,CAAC,GAE5B,OAAO,EAAe,IAAI,EACtB,IAAK,YACL,IAAK,uBAuCoB,EArCU,EAqCC,EArCU,EAsClD,CADsC,GAChC,EAAqB,EAAmB,EADQ,CACL,CAAC,GAClD,GAAI,EACA,OAAO,EAEX,IAAM,EAAU,CAAA,EAAA,AAHQ,EAGR,kBAAA,AAAkB,EAAC,EAAe,YAAY,CAAE,EAAU,KAAK,CAAE,kBAC3E,EAAiB,IAAI,MAAM,EAAS,CACtC,IAAK,CAAM,CAAE,CAAI,CAAE,CAAQ,EACvB,GAAI,OAAO,MAAM,CAAC,EAAS,GAIvB,IAJ8B,GAIvB,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,GAE5C,OAAO,GACH,IAAK,OAIG,MADA,CAAA,EAAA,EAAA,qBAAA,AAAqB,EADF,AACG,wDAAY,GAC3B,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAEhD,KAAK,SAIG,MADA,CAAA,EAAA,EAAA,qBAAA,AAAqB,EADF,AACG,yDAAY,GAC3B,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAEhD,SAEQ,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAEpD,CACJ,CACJ,GAEA,OADA,EAAmB,GAAG,CAAC,EAAgB,GAChC,CAvEH,KAAK,gBACL,IAAK,uBAwE2B,EArEU,EAqEC,EArEU,EAsEzD,CAD6C,GACvC,EAAqB,EAAmB,EADe,CACZ,CAAC,GAClD,GAAI,EACA,OAAO,EAMX,IAAM,EAAU,GAPQ,KAOA,OAAO,CAJA,AAIC,CAJA,GAK1B,EAAiB,IAAI,MAAM,EAAS,CACtC,IAAK,CAAM,CAAE,CAAI,CAAE,CAAQ,EACvB,GAAI,OAAO,MAAM,CAAC,EAAS,GAIvB,IAJ8B,GAIvB,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,GAE5C,OAAO,GACH,IAAK,OACD,CACI,IAAM,EAAa,wDACf,EAAU,kBAAkB,CAC5B,CAD8B,CACwB,EAAU,KAAK,CAAE,GACxC,iBAAiB,CAAzC,EAAe,IAAI,CAE1B,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAU,KAAK,CAAE,EAAY,EAAe,eAAe,EAGhF,CAAA,EAAA,EAAA,gCAAA,AAAgC,EAAC,EAAY,EAAW,GAE5D,MACJ,CACJ,IAAK,SACD,CACI,IAAM,EAAa,yDACf,EAAU,kBAAkB,CAC5B,CAD8B,CACwB,EAAU,KAAK,CAAE,GACxC,iBAAiB,CAAzC,EAAe,IAAI,CAE1B,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAU,KAAK,CAAE,EAAY,EAAe,eAAe,EAGhF,CAAA,EAAA,EAAA,gCAAA,AAAgC,EAAC,EAAY,EAAW,GAE5D,MACJ,CACJ,QAEQ,GAAoB,UAAhB,OAAO,GAAqB,CAAC,EAAA,mBAAmB,CAAC,GAAG,CAAC,GAAO,CAC5D,IAAM,EAAa,CAAA,EAAA,EAAA,4BAAA,AAA4B,EAAC,eAAgB,GAC5D,EAAU,kBAAkB,CAC5B,CAD8B,CACwB,EAAU,KAAK,CAAE,GAChE,AAAwB,iBAAiB,GAA1B,IAAI,CAE1B,CAAA,EAAA,EAAA,oBAAoB,AAApB,EAAqB,EAAU,KAAK,CAAE,EAAY,EAAe,eAAe,EAGhF,CAAA,EAAA,EAAA,gCAAA,AAAgC,EAAC,EAAY,EAAW,EAEhE,CACA,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAEpD,CACJ,EACA,IAAK,CAAM,CAAE,CAAI,EAKb,GAAoB,UAAhB,OAAO,EAAmB,CAC1B,IAAM,EAAa,CAAA,EAAA,EAAA,iCAAA,AAAiC,EAAC,eAAgB,GAUrE,OATI,EAAU,kBAAkB,CAC5B,CAD8B,CACwB,EAAU,KAAK,CAAE,GACxC,iBAAiB,CAAzC,EAAe,IAAI,CAE1B,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAU,KAAK,CAAE,EAAY,EAAe,eAAe,EAGhF,CAAA,EAAA,EAAA,gCAAA,AAAgC,EAAC,EAAY,EAAW,IAErD,CACX,CACA,OAAO,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EACtC,EACA,UACI,IAAM,EAAa,8DACf,GAAU,kBAAkB,CAC5B,CAD8B,CACwB,EAAU,KAAK,CAAE,GACxC,iBAAiB,CAAzC,EAAe,IAAI,CAE1B,CAAA,EAAA,EAAA,oBAAA,AAAoB,EAAC,EAAU,KAAK,CAAE,EAAY,EAAe,eAAe,EAGhF,CAAA,EAAA,EAAA,gCAAA,AAAgC,EAAC,EAAY,EAAW,EAEhE,CACJ,GAEA,OADA,EAAmB,GAAG,CAAC,EAAW,GAC3B,CAvKH,SACI,OAAO,CACf,CACJ,CAIA,SAAS,EAAyB,CAAsB,CAAE,CAAS,SAC/D,AAAI,EAAU,WAAW,CAGd,CAHgB,OAGR,OAAO,CAAC,CAAC,GAcb,EAAgC,EAGnD,CACA,IAAM,EAAqB,IAAI,QACzB,EAAgC,IAAI,QA+I/B,SAAS,EAAoC,CAAS,EAC7D,IAAM,EAAqB,EAA8B,GAAG,CAAC,GAC7D,GAAI,EACA,OAAO,EAEX,IAAM,EAAU,GAHQ,KAGA,OAAO,CAAC,CAAC,GAC3B,EAAiB,IAAI,MAAM,EAAS,CACtC,IAAK,SAAS,EAAI,CAAM,CAAE,CAAI,CAAE,CAAQ,SAChC,OAAO,MAAM,CAAC,EAAS,IAOP,GAPc,OAO9B,EAA4B,KAArB,GAA+B,SAAT,CAAmB,EAAC,EAAA,mBAAmB,CAAC,GAAG,CAAC,IACzE,CAD8E,CACzC,EAD4C,AACjC,GAHzC,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EAAM,EAMhD,EACA,IAAK,SAAS,EAAI,CAAM,CAAE,CAAI,EAQ1B,MAHoB,UAAhB,EAA4B,KAArB,GAA+B,SAAT,CAAmB,EAAC,EAAA,mBAAmB,CAAC,GAAG,CAAC,IACzE,CAD8E,CACzC,EAD4C,AACjC,GAE7C,EAAA,cAAc,CAAC,GAAG,CAAC,EAAQ,EACtC,EACA,QAAS,SAAS,IACd,EAAqC,EAAW,EACpD,CACJ,GAEA,OADA,EAA8B,GAAG,CAAC,EAAW,GACtC,CACX,CACA,SAAS,EAAgC,CAAsB,EAC3D,IAAM,EAAqB,EAAmB,GAAG,CAAC,GAClD,GAAI,EACA,OAAO,EAKX,IAAM,EAAU,GANQ,KAMA,OAAO,CAAC,GAwBhC,OAvBA,EAAmB,GAAG,CAAC,EAAwB,GAC/C,OAAO,IAAI,CAAC,GAAwB,OAAO,CAAC,AAAC,IACrC,AAAC,EAAA,mBAAmB,CAAC,GAAG,CAAC,IACzB,GADgC,IACzB,cAAc,CAAC,EAAS,EAAM,CACjC,MACI,IAAM,EAAgB,EAAA,oBAAoB,CAAC,QAAQ,GAInD,OAHI,GACA,CAAA,EAAA,EAAA,OADe,wBACf,AAA+B,EAAC,GAE7B,CAAsB,CAAC,EAAK,AACvC,EACA,IAAK,CAAK,EACN,OAAO,cAAc,CAAC,EAAS,EAAM,OACjC,EACA,UAAU,EACV,YAAY,CAChB,EACJ,EACA,YAAY,EACZ,cAAc,CAClB,EAER,GACO,CACX,CAwN0B,CAAA,EAAA,EAAA,2CAAA,AAA2C,EAAC,AAEtE,SAAS,AAAwB,CAAK,CAAE,CAAU,EAC9C,IAAM,EAAS,EAAQ,CAAC,OAAO,EAAE,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAO,cAAc,CAAK,AAAJ,MAAU,CAAA,EAAG,EAAO,KAAK,EAAE,EAAW,gIAAE,CAAC,EAA2I,CAAxI,CAAC,kBAA4J,CAClO,MAAO,OACP,YAAY,EACZ,aAAc,EAClB,EACJ,CAL8I,CAAC,CAH1G,CAAA,CAG6G,CAH7G,AAG8G,EAH9G,2CAAA,AAA2C,EAShF,AATiF,SASxE,AAAiC,CAAK,CAAE,CAAU,CAAE,CAAiB,CANmI,CAAC,AAO9M,IAAM,EAAS,EAAQ,CAAC,OAAO,EAAE,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAO,cAAc,CAAC,AAAI,MAAM,CAAA,EAAG,EAAO,KAAK,EAAE,EAAiO,SAAtN,EAAE,wLAAoN,EAAG,AAMhS,SAAS,AAA4B,CAAU,EAC3C,OAAO,EAAW,MAAM,EACpB,KAAK,EACD,MAAM,OAAO,cAAc,CAAC,IAAI,EAAA,cAAc,CAAC,uFAAwF,oBAAqB,CACxJ,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EACJ,MAAK,EACD,MAAO,CAAC,EAAE,EAAE,CAAU,CAAC,EAAE,CAAC,EAAE,CAChC,AADiC,MAC5B,EACD,MAAO,CAAC,EAAE,EAAE,CAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAU,CAAC,EAAE,CAAC,EAAE,CAAC,AAC1D,SACI,CACI,IAAI,EAAc,GAClB,IAAI,IAAI,EAAI,EAAG,EAAI,EAAW,MAAM,CAAG,EAAG,IAAI,AAC1C,GAAe,CAAC,EAAE,EAAE,CAAU,CAAC,EAAE,CAAC,IAAI,CAAC,CAG3C,OAAO,AADP,EAAe,CAAC,QAAQ,EAAE,CAAU,CAAC,EAAW,MAAM,CAAG,EAAE,CAAC,EAAE,CAAC,AAEnE,CACR,CACJ,EA5B4T,AA8B5T,GA9B+U,sCA8BtS,0BA9BwS,CAAC,AAAxQ,EAA8U,CAA3U,AAAwQ,CAAvQ,AAAwQ,kBAAuF,CACra,MAAO,KACP,YAAY,EACZ,cAAc,CAClB,EACJ,CALoZ,CAAC,CAAvQ,CAAC,GAAG,CAAC,gEAAgE,CAAC,GAAG,CAAC,iEAAiE,CAAC,GAAG,iFCjlB7R,IAAA,EAGO,EAAA,CAFLZ,AAEK,CAAA,OAGP,CAHkD,CAGnB,EAAA,CAAtBa,AAAsB,CAAA,EALb,CAKqD,IACvE,EAEEE,CANK,CAOLC,CAAAA,AAFAF,CAEAE,AAJqB,OAQvB,CAR+B,CAc7BE,EAA6B,CAL7BjB,AAOK,CAAA,CAbe,EACpBe,IAaF,EAA+B,EAHA,AAGkC,CAAxDrB,AAAwD,CAAA,KAf/B,CAOZ,CANpBoB,AAeF,CAJEG,AAVsC,CAgBtCE,CAfAH,CAgBK,CAFLE,AAEK,CAAA,AAJgB,IAA0C,GAKjE,CAL+B,CAGV,AAInBG,EACK,CAFLD,AAEK,CAAA,IAJA,EAhBiB,AAmBJ,CAEpB,EAASE,AAV8C,EAUK,CAAnDA,AAAmD,CAAA,CApBrD,AAmBA,AANuB,EAOsB,AANlDH,IAOF,EAA0C,CANG,AAIV,CAEO,AADkB,CACnDI,AAAiC,AAJd,CAIc,CAHxCF,MAoCK,SAASG,EACdC,CAAwB,CACxBvB,CAAoB,CAxDkB,CA0DtC,CArCgC,GAA6D,AAqCvFG,EAAgBL,CAtCuF,CAsCvFA,CArCkB,mBAqClBA,CAAqBG,QAAQ,GACnD,GAAIE,EACF,OAAQA,EAAcC,IAAI,AADT,EAEf,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOoB,EACLD,EACAvB,EACAG,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIX,EAAAA,cAAAA,CACR,kEADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,oBACH,MAAM,OAAA,cAEL,CAFK,IAAIA,EAAAA,cAAAA,CACR,uEADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,UAYD,OAAOsC,EAAyBP,EAItC,IAEFR,EAAAA,6BAAAA,GACF,CAIO,IAAMgB,EAAgCC,EAGtC,SAASC,EACdV,CAAwB,CACxBvB,CAAoB,EAEpB,IAAMG,EAAgBL,EAAAA,SAPuD,WAOvDA,CAAqBG,QAAQ,GACnD,GAAIE,EACF,OAAQA,EAAcC,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOoB,EACLD,EACAvB,EACAG,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIX,EAAAA,cAAAA,CACR,sEADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,KAAK,oBACH,OAAO0C,EAA6BX,EAAkBpB,EACxD,KAAK,UAYD,OAAO2B,AAmLRkB,EAnLiCzB,EAItC,IAEFR,EAAAA,gBA6KiCQ,aA7KjCR,GACF,CAEO,SAASiB,EACdT,CAAwB,CACxBvB,CAAoB,EAEpB,IAAMG,EAAgBL,EAAAA,oBAAAA,CAAqBG,QAAQ,GACnD,GAAIE,EACF,OAAQA,EAAcC,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACL,IAAK,gBACL,IAAK,mBACH,OAAOoB,EACLD,EACAvB,EACAG,EAEJ,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIX,EAAAA,cAAAA,CACR,8EADI,oBAAA,OAAA,kBAAA,iBAAA,CAEN,EACF,KAAK,oBACH,OAAO0C,EAA6BX,EAAkBpB,EACxD,KAAK,UAYD,OAAO2B,EAAyBP,EAItC,IAEFR,EAAAA,6BAAAA,GACF,CAEO,SAASoB,EACdZ,CAAwB,EAExB,IAAMvB,EAAYH,EAAAA,gBAAAA,CAAiBI,QAAQ,GAC3C,GAAI,CAACD,EACH,MAAM,GADQ,IACR,cAEL,CAFK,IAAIR,EAAAA,cAAAA,CACR,8DADI,oBAAA,OAAA,kBAAA,iBAAA,CAEN,GAGF,IAAMW,EAAgBL,EAAAA,oBAAAA,CAAqBG,QAAQ,GACnD,GAAIE,EACF,OAAQA,EAAcC,IADL,AACS,EACxB,IAAK,YACL,IAAK,mBACH,IAAMgC,EAAiBjC,EAAckC,mBAAmB,CACxD,GAAID,GACF,IAAK,IAAIE,KAAOf,AADE,EAEhB,GAAIa,EAAe5D,GAAG,CAAC8D,GAKrB,GAN8B,AACH,GAK3B,CAAA,EAAOnB,EAAAA,kBAAAA,EACLhB,EAAcoC,YAAY,CAC1BvC,EAAUwC,KAAK,CACf,WAGN,CAEF,KACF,KAAK,QACL,IAAK,gBACL,IAAK,iBACH,MAAM,OAAA,cAEL,CAFK,IAAIhD,EAAAA,cAAAA,CACR,iFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EAQJ,CAKF,OAAOiD,QAAQC,OAAO,CAACnB,EACzB,CAEA,SAASC,EACPD,CAAwB,CACxBvB,CAAoB,CACpB2C,CAAoC,EAEpC,OAAQA,EAAevC,IAAI,EACzB,IAAK,YACL,IAAK,mBAAoB,CACvB,IAAMgC,EAAiBO,EAAeN,mBAAmB,CACzD,GAAID,GACF,IAAK,IAAME,KADO,AACAf,EAChB,GAAIa,EAAe5D,GAAG,CAAC8D,GAKdM,GALoB,AADK,EA6H1CrB,EAtHYA,EAuHZvB,EAtHYA,EAuHZ2C,EAtHYA,EAwHZ,CAHoB,GADI,AAIlBuB,EAAed,EAAaG,EAFQ,CAEL,CAAChC,GACtC,GAAI2C,EACF,OAAOA,EAGT,GAJkB,CAIZC,EAAU,IAAIH,MAAAA,CAAAA,EAClB7C,EAAAA,kBAAAA,EACEwB,EAAeJ,YAAY,CAC3BvC,EAAUwC,KAAK,CACf,YAEFc,GAKF,OAFAF,EAAagB,GAAG,CAAC7C,EAAkB4C,GAE5BA,CAxIKxB,CAGN,CAEF,KACF,CACA,IAAK,gBAAiB,CACpB,IAAMP,EAAiBO,EAAeN,mBAAmB,CACzD,GAAID,GACF,IAAK,IAAME,KAAOf,AADA,EAEhB,GAAIa,EAAe5D,GAAG,CAAC8D,GACrB,GAFgC,AACL,IAgIvC,AA/HmBO,SA+HVA,AACPtB,CAAwB,CACxBa,CAAmC,CACnCpC,CAAoB,CACpB2C,CAAwD,EAExD,IAAMuB,EAAed,EAAaG,GAAG,CAAChC,GACtC,GAAI2C,EACF,OAAOA,EAGT,GAJkB,CAIZG,EAAsB,CAAE,GAAG9C,CAAgB,AAAC,EAK5C4C,EAAU1B,QAAQC,OAAO,CAAC2B,GA6EhC,OA5EAjB,EAAagB,GAAG,CAAC7C,EAAkB4C,GAEnCpG,OAAOuG,IAAI,CAAC/C,GAAkBgD,OAAO,CAAC,AAACd,IACjCxC,EAAAA,mBAAAA,CAAoBzC,GAAG,CAACiF,KAItBrB,EAJ6B,AAId5D,GAAG,CAACiF,IACrB1F,GAD4B,IACrByG,cAAc,CAACH,EAAqBZ,EAAM,CAC/CF,MACE,IAAMkB,EAAAA,CAAAA,EAAazD,EAAAA,4BAAAA,EAA6B,SAAUyC,GAO9B,iBAAiB,CAAzCd,EAAevC,IAAI,IAErBQ,EAAAA,oBAAAA,EACEZ,EAAUwC,KAAK,CACfiC,EACA9B,EAAe+B,eAAe,KAIhC/D,EAAAA,gCAAAA,EACE8D,EACAzE,EACA2C,EAGN,EACAgC,YAAY,CACd,GACA5G,OAAOyG,cAAc,CAACL,EAASV,EAAM,CACnCF,MACE,IAAMkB,EAAAA,CAAAA,EAAazD,EAAAA,4BAAAA,EAA6B,SAAUyC,GAO9B,iBAAiB,CAAzCd,EAAevC,IAAI,IAErBQ,EAAAA,oBAAAA,EACEZ,EAAUwC,KAAK,CACfiC,EACA9B,EAAe+B,eAAe,KAIhC/D,EAAAA,gCAAAA,EACE8D,EACAzE,EACA2C,EAGN,EACAyB,IAAIQ,CAAQ,EACV7G,OAAOyG,cAAc,CAACL,EAASV,EAAM,CACnCoB,MAAOD,EACPE,UAAU,EACVH,WAAY,EACd,EACF,EACAA,YAAY,EACZI,cAAc,CAChB,IAEEZ,CAAe,CAACV,EAAK,CAAGlC,CAAgB,CAACkC,EAAK,CAGtD,GAEOU,CACT,EA5Nc5C,EACAa,EACApC,EACA2C,EAGN,CAGJ,CAKF,CAKE,OAAOK,EAA0BzB,EAErC,CAEA,SAASW,EACPX,CAAwB,CACxBpB,CAA0C,EAE1C,MAAA,CAAA,EAAOW,EAAAA,sBAAAA,EACLX,EAGI6C,EAA0BzB,GAElC,CAwCA,IAAM6B,EAAe,CA5CjB3B,GA4CqB4B,KA5Cb3B,GA8CN4B,AA9CS,CAACR,CA8CkD,CAChES,IAAK,SAASA,AAAIC,CAAM,CAAEC,CAAI,CAAEC,CAAQ,EACtC,CAhDmC,EAgDtB,CA/CTX,QA+CAU,GAAmBA,AAAS,SA/CRlC,IA+C4B,YAATkC,EAAoB,CAC7D,IAAME,EAAiBjD,EAAAA,cAAAA,CAAe6C,GAAG,CAACC,EAAQC,EAAMC,GAExD,MAAO,CAAA,CACL,CAACD,EAAK,CAAE,CAAC,GAAGG,KACV,IAAMC,EAAQxC,EAAAA,yBAAAA,CAA0BpB,QAAQ,GAQhD,OANI4D,GACFA,EAAMC,EADG,aACY,CAACC,KAAK,CACzB,OAAA,cAA8D,CAA9D,AAAIhF,MAAM,CAAC,iDAAiD,CAAC,AAA7D,oBAAA,OAAA,mBAAA,gBAAA,CAA6D,IAI1D,IAAIiF,MACTL,EAAeM,KAAK,CAACT,EAAQI,GAC7BN,EAEJ,EACF,CAAA,AAAC,CAACG,EACJ,AADS,CAGT,OAAO/C,EAAAA,cAAAA,CAAe6C,GAAG,CAACC,EAAQC,EAAMC,EAC1C,CACF,EA0HA,SAASV,EAA0BzB,CAAwB,EACzD,IAAM2C,EAAed,EAAaG,GAAG,CAAChC,GACtC,GAAI2C,EACF,OAAOA,EAMT,GAPkB,CAOZC,EAAU1B,QAAQC,OAAO,CAACnB,GAYhC,OAXA6B,EAAagB,GAAG,CAAC7C,EAAkB4C,GAEnCpG,OAAOuG,IAAI,CAAC/C,GAAkBgD,OAAO,CAAC,AAACd,IACjCxC,EAAAA,mBAAAA,CAAoBzC,GAAG,CAACiF,KAIxBU,CAAe,CAJgB,AAIfV,EAAK,CAAGlC,CAAgB,CAACkC,EAAK,AAALA,CAE/C,GAEOU,CACT,CA+KMsB,CAAAA,EAAoBrE,EAAAA,2CAAAA,EACxB0E,AAMF,SAASA,AACPtD,CAAyB,CACzBiC,CAAkB,EAElB,IAAMpG,EAASmE,EAAQ,CAAC,OAAO,EAAEA,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAA,cAIN,CAJM,AAAIzD,MACT,CAAA,EAAGV,EAAO,KAAK,EAAEoG,EAAW,0HAAE,CAAC,EAD1B,CAEH,CAAC,kBAFE,OAAA,kBAAA,eAEwD,CAAC,CAFzD,CAIP,CADI,CAAC,AAEP,GAbMiB,CAAAA,EACJtE,EAAAA,2CAAAA,EAA4C2E,AAc9C,SAJqE,AAI5DA,AACPvD,CALoE,AAK3C,CACzBiC,CAAkB,CAClBkB,CAAgC,EAEhC,IAAMtH,EAASmE,EAAQ,CAAC,OAAO,EAAEA,EAAM,EAAE,CAAC,CAAG,cAC7C,OAAO,OAAA,cAON,CAPM,AAAIzD,MACT,CAAA,EAAGV,EAAO,KAAK,EAAEoG,EAIf,SAJ0B,EAAE,oKAI5B,EAKN,AALSuB,SAKAA,AAA4BC,CAAyB,EAC5D,OAAQA,EAAWJ,MAAM,EACvB,KAAK,EACH,MAAM,OAAA,cAEL,CAFK,IAAIrG,EAAAA,cAAAA,CACR,uFADI,oBAAA,OAAA,mBAAA,gBAAA,CAEN,EACF,MAAK,EACH,MAAO,CAAC,EAAE,EAAEyG,CAAU,CAAC,EAAE,CAAC,EAAE,CAAC,AAC/B,MAAK,EACH,MAAO,CAAC,EAAE,EAAEA,CAAU,CAAC,EAAE,CAAC,SAAS,EAAEA,CAAU,CAAC,EAAE,CAAC,EAAE,CAAC,AACxD,SAAS,CACP,IAAIC,EAAc,GAClB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAWJ,MAAM,CAAG,EAAGM,IAAK,AAC9CD,GAAe,CAAC,EAAE,EAAED,CAAU,CAACE,EAAE,CAAC,IAAI,CAAC,CAGzC,OAAOD,AADPA,EAAe,CAAC,QAAQ,EAAED,CAAU,CAACA,EAAWJ,MAAM,CAAG,EAAE,CAAC,EAAE,CAAC,AAEjE,CACF,CACF,EAxBqCF,GAAmB,gEAAE,CAJvB,AAIwB,EALlD,CAEH,AAIA,CAJC,AAIA,kBANE,OAAA,mBAAA,cAEwD,CAAC,CAFzD,CAOP,CAJI,AAG+D,CAErE,AALO,AAG+D,gEAHC,CAAC,GAClE,CAAC,KCluBP,EAA+B,EAAkC,CAAA,AAAxDnG,CAAwD,OAY1D,MAZgB,GAYP4G,CAZiD,CAYlC,CAW9B,EAvB8B,AAYA,GAAA,CAC7BC,WAAS,IDqtB+C,CAAC,GACrD,MCrtBJC,CAAY,QACZC,CAAM,UAENC,CAAQ,CAMT,CAX8B,CAYM,EACjC,IAGIG,EACAC,EAJE,kBAAE/G,CAAgB,CAAE,CACxB6G,EAAQ,CAAA,CAAA,IAAA,GAMJ7C,EAAQhE,EAAiBI,CAhB4B,OAgBpB,GACvC,GAAI,CAAC4D,EACH,KADU,CACJ,OAAA,cAEL,CAFK,IAAIrE,EAAAA,cAAAA,CACR,4EADI,oBAAA,OAAA,kBAAA,iBAAA,CAEN,GAGF,GAAM,8BAAEqH,CAA4B,CAAE,CACpCH,EAAQ,CAAA,CAAA,IAAA,GACVC,EAAqBE,EAA6BP,EAAczC,GAEhE,GAAM,wBAAEvC,CAAsB,CAAE,CAC9BoF,EAAQ,CAAA,CAAA,IAAA,GAGV,OAAA,AAFAE,EAAetF,EAAuBiF,EAAQ1C,GAE9C,CAAA,CAAA,CAAO,EAAA,GAAA,EAACwC,EAAAA,CAAUE,OAAQK,EAAcN,aAAcK,GACxD,CAUF,MAVS,sECjDT,EAA+B,EAAkC,CAAxDnH,AAAwD,CAAA,OAY1D,MAZgB,GAYPwH,CAZiD,CAY/B,CAWjC,EAvB8B,AAYG,GAAA,WAChCX,CAAS,OACTY,CAAK,QACLV,CAAM,SAENpC,CAAO,CAMR,CAXiC,CAYG,EACjC,IAGIyC,EAHE,kBAAE/G,CAAgB,CAAE,CACxB6G,EAAQ,CAAA,CAAA,IAAA,GAKJ7C,EAAQhE,EAAiBI,IAf4B,IAepB,GACvC,GAAI,CAAC4D,EACH,KADU,CACJ,OAAA,cAEL,CAFK,IAAIrE,EAAAA,cAAAA,CACR,sGADI,oBAAA,OAAA,kBAAA,gBAAA,EAEN,GAGF,GAAM,wBAAE8B,CAAsB,CAAE,CAC9BoF,EAAQ,CAAA,CAAA,IAAA,GAGV,OAFAE,AAEA,EAFetF,EAAuBiF,EAAQ1C,GAE9C,CAAA,CAAA,CAAO,EAAA,GAAA,EAACwC,EAAAA,CAAW,GAAGY,CAAK,CAAEV,OAAQK,GACvC,CAMF,MANS,6DCrCF,IAAMM,EAAW,IAItB,CAAA,EAAO,EAAA,GAAA,EAACC,OAAAA,CAAKvH,KAAK,2FCVpB,EAAqC,EAAA,CAA5BwH,AAA4B,CAAA,OAApB,AAGjB,EAHmBC,GAAG,IAGbC,EAAe,CAIvB,CAP6B,CAGN,GAAA,IAHa,KAInCnD,CAAO,CAGR,CAJuB,EAKhB,OAAEhG,CAAK,CAAEC,QAAM,CAAE,CAAGiJ,CAAAA,EAAAA,EAAAA,GAAAA,EAAIlD,GAC9B,GAAIhG,EAMF,KANS,CACLC,IAGAD,EAAcC,EAHN,IAGY,CAAGA,CAAAA,EAErBD,EAER,OAAO,IACT,CAEO,SAASoJ,EAAoB,CAInC,EAJmC,GAAA,SAClCpD,CAAO,CAGR,CAJmC,EAKlC,MAAA,CAAA,EACE,EAAA,GAAA,EAACiD,EAAAA,AADH,QACGA,CAAAA,CAASI,SAAU,cAClB,CAAA,EAAA,EAAA,GAAA,EAACF,EAAD,AAACA,CAAenD,QAASA,KAG/B,qIC7BA,IAAA,EAEE9E,EACAC,CAFAF,AAEAE,CAAAA,MADsB,CAOxB,CANEA,AAAoB,EACpBC,CAKIkI,EAAY,CAChB,CAACrI,EAAAA,IATqB,EACtBC,YAEyB,IAMxBD,CAAuB,CAAE,EALrB,OAK+B,UAAEqB,CAAQ,CAA2B,EACvE,EANyB,KAMlBA,CACT,EACA,CAACpB,EAAAA,sBAAAA,CAAuB,CAAE,SAAU,UAAEoB,CAAQ,CAA2B,EACvE,OAAOA,CACT,EACA,CAACnB,EAAAA,oBAAAA,CAAqB,CAAE,SAAU,UAAEmB,CAAQ,CAA2B,EACrE,OAAOA,CACT,EACA,CAAClB,EAAAA,yBAAAA,CAA0B,CAAE,SAAU,UACrCkB,CAAQ,CAGT,EACC,OAAOA,CACT,CACF,EAEaiH,EAGXD,CAAS,CAACrI,EAAAA,aADV,AADA,SAEUA,CAAuBuI,KAAK,CAAC,GAAoC,CAAA,AAEhEC,EAGXH,CAAS,CAACpI,EAAAA,aAFV,AACA,SACUA,CAAuBsI,KAAK,CAAC,GAAoC,CAAA,AAEhEE,CARiD,CAW5DJ,CAAS,CAACnI,EAAAA,WAFV,AACA,IAXgF,KAYtEA,CAAqBqI,KAAK,CAAC,GAAkC,CAAA,AAE5DG,EAGXL,CAX4D,AAWnD,CACPlI,EAAAA,eAHF,AACA,EAXgF,QAa9EA,CAA0BoI,KAAK,CAAC,EAP0B,CAQ3D,CAAA,kBAT+E,qBAMpB,oBADoB","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70]}